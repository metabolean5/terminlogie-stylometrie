L'intérêt principal des grammaires de types logiques dont les grammaires catégorielles (GC) est  leur lien direct et transparent avec la sémantique formelle compositionnelle. Ce lien est établi pour une phrase générée à travers l'isomorphisme entre une preuve de correction du choix des types pour les mots dans la phrase et l'expession sémantique extraite de cette preuve. Les relations syntaxiques entre les mots définies par les types sont formaliseés par un calcul logique de types qui n'est pas spécifique à une grammaire mais à une classe de grammaires. On construit ainsi des interfaces simples et élégantes entre la syntaxe et la sémantique à la base de principes plus ou moins universels. Tant que les relations entre les mots (dépendances) s'accordent bien avec les relations de précédence (ordre des mots), à savoir lorsqu'elles ne dépassent jamais les limites des domaines syntaxiques l ocaux des mots (dépendances projectives), les preuves de correction sont isomorphes aux systèmes de constituents des phrases. A ce niveau de représentation syntaxique il est en principe possible de définir les types directement en termes de dépendances. En fait, les premières définitions des grammaires de dépendances (GD) (Gaifman, 1961) ont été similaires à celle des GC classiques (Bar-Hillel, 1953) . Cependant, il existe dans  toute langue des dépendances non bornées par les domaines locaux (dépendances non projec-  tives). Elles sont dues aux formes et aux mots fonctionnels discontinus (comme les particules négatives, les pronoms comparatifs, etc.), ou à l'interférence des éléments des structures extrasyntaxiques telles que la structure communicative (cf. la topicalisation), la co-référence, les relations de portée, etc. ou, au contraire, sont dues au manque en surface, des membres des relations sémantiques (comme c'est le cas de la relativisation ou de l'extraction au cours de la coordination). Pour y faire face les calculs logiques sont complétés par des règles qui, d'un côté, rendent les preuves plus flexibles au détriment du lien direct avec les constituents, e.g. en montant les types (Lambek, 1961; Steedman, 1996), et d'un autre côté, les rendent plus sélectives, e.g. en choisissant les règles structurelles spécifiques en foncion de connecteurs différents (règles multimodales dues à Oehrle, Morrill, Moortgat et Hepple (Morrill, 1994; Moortgat, 1997)). Avec ces moyens on peut exprimer les dépendances non bornées tout en gardant l'interprétation sémantique compositionnelle. En même temps, à cause de l'expressivité accrue, la complexité des preuves devient exponentielle, voire pire. Dans l'article (Dikovsky, 2004), nous avons proposé une nouvelle architecture compositionnelle de types invariables de dépendances (sans montée des types). Elle est établie sur la base de la distinction faite entre les types neutres des dépendances projectives, qui sont formalisés par la règle classique d'élimination d'arguments, et les types des dépendances non bornées (valences) dotés de polarisation et d'orientation, qui sont formalisés par une règle appelée FA (first avai- lable) de saturation (appariement) des valences. La base psycholinguistique de cette règle est l'hypothèse que les dépendances non bornées sont gérées par les piles dans la mémoire dynamique d'analyse. FA sélectionne la plus proche valence polarisée duale dans la direction indiquée. Elle est conforme avec la majorité des dépendances non projectives dans maintes langues. On a élaboré différents calculs de dépendances avec la règle FA (Dekhtyar & Dikovsky, 2004; Dekhtyar & Dikovsky, 2007). Les Grammaires Catégorielles de Dépendances (CDG) correspondantes s'avèrent expressives. En même temps, elles disposent d'algorithmes d'analyse en temps polynomial. Tout de même, la règle FA n'est pas universelle. Par exemple, elle n'est pas adaptée aux dépendances croisées illimitées du hollandais exposées dans (Bresnan et al., 1982). C'est pourquoi, dans cet article nous explorons une autre règle d'appariement FC (first cross) qui sélectionne la première valence polarisée duale croisée dans la direction indiquée. Ainsi, la structure dynamique de mémoire qui correspond à cette règle est la file d'attente. FC explique les dépendances croisées illimitées en termes d'un langage simple de structures de dépendances et non en termes du langage de copies, comme d'habitude. A l'instar de grammaires multimodales de types, nous définissons les CDG multimodales (mmCDG) où les règles d'appariement sont considérées comme les modes de compositionnalité propres aux dépendances non projectives. Nous montrons que la règle FC est aussi efficace que la règle FA et nous présentons un algorithme d'analyse syntaxique de ces grammaires en temps polynomial. Les CDG sont des grammaires catégorielles (GC) qui, à la différence des GC classiques, définissent explicitement les relations de dépendance entre les mots dans la phrase et non les relations de dominance entre les constituants. Elles peuvent déterminer les structures de dé- pendances (SD) plus générales que les arbres de dépendances (AD). Une SD d'une phrase w = w . . . w est un graphe orienté dont les noeux sont les mots w , . . . , w ordonnés par l'ordre dans w, avec un noeux sélectionné (la tête) et dont les arcs sont étiquetés par les noms  Figure 1   des dépendances. E.g., la SD en figure 1 est un AD dont la tête (sa racine) est le mot était.  Comme toutes les GC, les CDG n'ont pas de règles. Une CDG peut être vue comme un lexique qui affecte à chaque mot un ensemble de types de dépendances. La particularité essentielle des types des CDG est la distinction faite entre les types de dépendances projectives qui relient le gouverneur à ses subordonnés appartenants à son domaine local, et les types de dépendances non projectives (non bornées) qui le relient aux subordonnés déplacés vers les domaines des autres mots. Les premiers sont définis par les sous types arguments des types du gouverneur, tandis que les derniers sont définis par les valences dotées d'une polarisation et d'une orientation (gauche / droite) dont l'ensemble constitue pour chaque type son potentiel. Formellement, les types de dépendances sont construits à partir d'un ensemble C de types primitifs et d'un ensemble V (C) de valences polarisées. Les éléments de C sont les noms des relations de dépendance, dont un type sélectionné S (l'axiome). Les valences dans V (C) sont orientées : V (C) = V (C)  V (C), où V (C) consiste des valences gauches d (négative), d (posi- tive) et V (C) consiste des valences droites d (positive), d (négative) où d  C. Un type (de dépendance) est une expression  , où  est un type basique et P est un potentiel. gCat (C) va noter l'ensemble des types sur C. Les types basiques B(C) sur C sont les types fonctionnels traditionnels du 1 ordre destinés à définir les dépendances projectives : 1. C  B(C). 2. Si   C et   B(C), alors [\], [ \], [/], [/]  B(C). 2 Les constructeurs \, / étant supposés associatifs, tout type basique peut être représenté sous la forme [a \...\a \f /a /.../a ]. Intuitivement, f est la dépendance du gouverneur et a , a correspondent aux dépendances des subordonnés gauches et droites. d correspond à la dépendance d itérée. f = S est le type des SD correctes. Les potentiels sont les suites de valences polarisées. Ils sont destinés à définir les dépendances non projectives. Dans le cas de dépendances projectives, ils sont vides. Les types avec le potentiel vide sont neutres. Par exemple, l'AD projectif en figure 1 est défini par les types neutres suivants : au  [ccopul/preposa] commencement  [preposa] le  [det] était  [ccopul\S/pred] Verbe  [det\pred] Les valences d et d, d  C, peuvent être vues comme les parenthèses gauches. Respectivement, d et d sont les parenthèses droites. Pour une valence gauche, e.g. d, la valence correspondante (duale) droite, d, est notée d = d. Ensemble ces valences duales appariées définissent la dépendance non projective d. L'adjacence est exprimée en utilisant les types primitifs d'ancrage : pour ancrer une valence négative v  { d, d || d  C} (la fin d'une dépendance non projective), c'est-à-dire la placer auprès d'un mot d'appui, sont utilisés les types primitifs particuliers d'ancrage : #(v) dont l'élimination signifie l'adjacence des mots et ne crée aucune dépendance. E.g., l'AD non projectif en figure 2 est défini par  Figure 2   les types qui ancrent les clitiques la, lui sur l'auxiliaire a :  elle  [pred] a  [#( clit iobj)\#( clit dobj)\pred\S/aux] la  [#( clit dobj)] lui  [#( clit iobj)] donnée  [aux] Le sens exact des types est défini par le calcul de dépendances suivant :  L  . C [C\] [] I . C [C \] [C \]  . [C \] [] D .   , si P ( C)P ( C)P satisfait la règle d'appariement M.  L  est la règle classique d'élimination. En éliminant le sous-type argument C = #(), elle crée la dépendance projective C et concatène les potentiels. C = #() ne crée aucune dépendance. I crée k > 0 exemplaires de C.  sert pour le cas k = 0 et pour éliminer le sous-type itéré. D apparie et élimine deux valences duales C et C selon la règle d'appariement M et crée la dépendance non projective C. Voici deux règles importantes d'appariement :  FA  : P n'a pas d'occurrence de C, C (apparier à la plus proche valence duale disponible).  FC  : P et P n'ont pas d'occurrences, respectivement, de C et de C (apparier à la premiere valence duale croisée, c'est-à-dire à la plus lointaine disponible).  On voit que les valences ressamblent aux traits Slash des GPSG, HPSG, mais à la place de règles  complexes de « propagation »des traits Slash les CDG utilisent les règles simples d'appariement FA et FC. En admettant que toute dépendance non projective C peut avoir sa propre règle d'appariement M nous considérons cette règle comme un mode de compositionnalité à travers C. Nous obtenons ainsi par analogie avec l'architecture multimodale pour les grammaires de Lambek (Morrill, 1994; Moortgat, 1997) la notion suivante de grammaire.  Définition 1 Une grammaire catégorielle multimodale de dépendances (mmCDG) est une  structure G = (W, C, S, , µ), où W est un vocabulaire,  (le lexique) est une fonction qui affecte à chaque mot dans W un sous ensemble fini de types dans gCat(C) et µ est une fonction qui affecte une règle d'appariement à toute dépendance non projective dans C. Le calcul de dépendances détermine la relation de prouvabilité correspondante sur les suites de types. La prouvabilité sans règles D (c'est-à-dire, au cas de dépendances projectives) est notée . Pour une SD D et une phrase w, la relation G(D, w) signifie : « D est créée au cours d'une preuve  S pour une suite de types   (w) ». Le langage et le langage des SD générés par G sont respectivement les ensembles L(G)= {w | D G(D, w)} et (G)= {D | w G(D, w)}. mmCDG et L(mmCDG ) sont respective- ment la famille des grammaires et des langages correspondants.  Les mmCDG sont très expressives. Avec la règle FA elles génèrent tous les langages non  contextuels (algébriques), mais aussi maints langages contextuels dont {a b c | n > 0}, les langages L = {a a ...a || n  1} (Dikovsky, 2004) qui sont faiblement contextuels mais non-TAG à partir de m > 4, le langage M IX, qui contient toutes permutations des motifs a b c , n > 0, M IX = {w  {a, b, c} || |w| = |w| = |w| }. Or, selon l'hypothèse de E.  Bach, M IX n'est pas faiblement contextuel, ainsi il ne serait pas généré par une grammaire  minimaliste, ou multi-TAG, etc. Dans (Dekhtyar & Dikovsky, 2007) on peut trouver d'autres exemples et une preuve du fait que L(mmCDG ) est une famille abstraite de langages (AFL).  D'un autre côté, nous croyons (Dikovsky, 2004; Dekhtyar & Dikovsky, 2004) que le langage de  copies L = {ww || w  {a, b} }, qui est généré par une grammaire TAG, n'appartient pas à la famille L(mmCDG ). Ce langage est d'un intérêt particulier parce qu'on croit qu'il est un modèle de la construction en néerlandais dite des « dépendances croisées illimitées ». Il s'agit des phrases n n . . . n n v v . . . v , dont un exemple est en figure 3, où  il y a une dépendance prédicative n  pred  v entre le verbe v en forme finie et le nom n ,  les dépendances prédicatives n  pred  v entre les verbes v à l'infinitif et les noms n ,  pour tout 2  i  m, et éventuellement, une dépendance d'objet direct n  dobj  v si le verbe v est transitif et le nom n est présent (c'est-à-dire, n = ). Jan Piet Marie les enfants a vu aider faire nager Figure 3.  Par ailleurs, une analyse plus approfondie de cette construction (Pulman & Ritchie, 1985)  montre que l'accord des formes existe seulement entre n et v . Sinon, la forme du nom subordonné est déterminée seulement par le verbe transitif v et son argument n . Cela implique que le vrai modèle de cette construction n'est point le langage L , mais le langage des SD  = {D || m > 0} sur W = N  V, où N  V = , D est la SD en figure 4 et n  N, v  V. En même temps, le langage correspondant est algébrique (voire linéaire).  Figure 4. AD D   Le langage   est généré par la mmCDG suivante :  G  = n  [#(L)] , [#(L)\#(L)] , pour n  N v  [#(L)\S/R] , [R/R] , [R] , pour v  V  E.g., une preuve de D    est montrée en figure 5. Figure 5. Notre solution du problème des dépendances croisées repose sur l'indépendance des types basiques et des valences polarisées dans les preuves du calcul de dépendances. Cette propriété est exprimée en termes de projections et de suites de catégories bien appariées.  Pour une suite de catégories   gCat(C)  ses projections locale  et de valences  sont définies ainsi : pour tous   gCat(C),   gCat(C) et C  gCAT (C),  1.   =  = ;  =   et  =   2. C = C et C = P.  Pour un potentiel P, sa projection P  sur une paire de valences duales vd,  vd est définie comme h(P ) pour l'homomorphisme h() =  si   {vd,  vd } et h() =  sinon. P est dit équilibré si toute projection P est bien appariée au sens habituel.  Soit |P |  le nombre d'occurrences de x dans P. Alors l'équilibre d'un potentiel P est incrémentalement vérifiable en utilisant les quantités suivantes pour toute   V (C) et    V (C) :  (P ) = max{|P |  |P | || P est un suffixe de P },  (P ) = max{|P |  |P | || P est un préfixe de P }. Elles expriment respectivement le déficit des parenthèses droites et gauches dans P (c'està-dire, le nombre de parenthèses droites (gauches) qu'il faut rajouter à P de droite (de gauche) pour qu'il devienne équilibré. Les propriétés suivantes sont vérifiées (Dekhtyar & Dikovsky, 2004; Dekhtyar & Dikovsky, 2007) :  Lemme 1 1. Quels que soient des potentiels P  , P et des valences   V (C),    V (C),  (P P ) =  (P ) + max{ (P )   (P ), 0},  (P P ) =  (P ) + max{ (P )   (P ), 0}. 2. Un potentiel P est équilibré ssi  (P ) = 0.  La propriété suivante d'indépendance des projections (Dekhtyar & Dikovsky, 2004; Dekhtyar  & Dikovsky, 2007) garantit l'existence d'un algorithme polynomial d'analyse de mmCDG .  Théorème 1 Pour une mmCDG G = (W, C, S, , µ) avec le mode FA et x  W  , x  L(G) ssi il y a une suite   (x) telle que  S et  est équilibré.  Le seul point de sa preuve sensible aux modes est la proposition suivante vraie pour FA :   Lemme 2 Un potentiel P est équilibré ssi pour toute catégorie   il y a une preuve   utilisant exclusivement les règles D et D .  Pour garantir l'indépendance des projections (et par conséquent, une analyse polynomiale) pour  une mmCDG , il faut prouver ce lemme pour tout mode M  M. En prouvant le lemme 2 pour FC, nous avons étendu le théorème 1 aux mmCDG avec les modes FA, FC :  Théorème 2 Pour x  W  et pour une mmCDG G = (W, C, S, , µ) avec M = {FA}, ou M = {FC} ou M = {FA, FC}, x  L(G) ssi il y a une suite   (x) telle que  S et  est équilibré.  Corollaire 1 L(mmCDG  ) = L(mmCDG ) = L(mmCDG ).  Dans l'article (Dekhtyar & Dikovsky, 2004) un algorithme d'analyse en temps polynomial a été  décrit pour une version sous commutative du calcul de dépendances . Dans l'article (Dekhtyar & Dikovsky, 2007) cet algorithme a été étendu aux mmCDG . Ce même algorithme à un détail près s'applique aussi aux mmCDG . Nous l'exposons en figure 6.  Fonctions d'échec. Soit une mmCDG  G = (W, C, S, , µ) avec les valences polarisées gauches V (C) = {v , . . . , v } et droites V (C) = { v , . . . ,  v }. Nous allons d'abord définir deux fonctions d'échec qui vont servir pour une optimisation de l'analyse. Soit w = w w ...w  W . Alors, pour 1  i  n,   V (C) et   V (C),  (, i) = max{ (  ) ||   (w ...w )},  (, i) = max{ (  ) ||   (w ...w )} sont les fonction d'échec gauche et droite. On suppose que  (, 0) =  (, 0) = 0. Algorithme d'analyse syntaxique. mmCdgPars est un algorithme typique de « programmation dynamique ». Il s'applique à une mmCDG et à une phrase w = w w ...w  W et remplit une matrice triangulaire M dont la dimension est n × n. L'élément M [i, j], i  j, de M correspond à l'intervalle w ...w de la phrase et représente un ensemble fini d'« items ». Un item est une expression I = C,  ,  , I , I qui code une catégorie C , où C est une catégorie basique (C  B(C)),  = ( , . . . ,  ) et  = ( , . . . ,  ) sont les vecteurs entiers dont chaque composante i correspond à la valence v , respectivement  v , et vaut le déficit correspondant des v -parenthèses droites (gauches) dans le potentiel P. Finalement, I , I sont les identificateurs des items dans les angles gauches et droites de M à partir desquelles est calculé l'item I (pour tout I  M [i, i] I = I = ).  Complexité. Pour une mmCDG  G = (W, C, S, , µ), soit l = || le nombre d'affectations des catégories aux mots dans le lexique, soit a = max{k || x  W ([ \...\ \C/]   (x)  [\C/ /.../ ]  (x))} le nombre maximal de sous types arguments dans les catégories affectées, soit p = |V (C)| = |V (C)| le nombre de valences polarisées et  = max { (P ) || x  W (C  (x)    V (C))} le déficit maximal des valences parenthèses dans les catégories affectées. Finalement, soit n la longueur de la phrase analysée.  Théorème 3 L'algorithme mmCdgPars a une complexité en temps O(l  ·a ·( ·n) ·n ).  Remarque 1 1. Pour une grammaire fixée G, les valeurs l  , a , p et  sont constantes. Si G varie, alors le problème d'appartenance devient N P -complèt (Dekhtyar & Dikovsky, 2004). 2. Si G est sans valence polarisée, alors la complexité est O(n ). 3. Soit le déficit maximal de valences  (n) des potentiels survenants dans les preuves des phrases dont la longueur est limitée par n. Si  (n) est bornée par une constante c, alors G peut être transformée en une mmCDG G sans valence polarisée dont le langage est algébrique (Dikovsky, 2001). Or, la taille de G est exponentielle par rapport à G. Si, de plus, le nombre des dépendances non bornées dans une SD engendrée par G n'est jamais supérieur à une borne constante uniforme (ce qui est typique pour maintes langues), alors la complexité est O(n ) pour la même grammaire G. 4. D'un autre côté, même si toute dépendance de G (sauf S) était définie par une valence polarisée, la complexité serait toujours polynomiale. Cette remarque explique que les mmCDG sont bien adaptées aux langages avec l'ordre flexible. Les limites de cet article ne nous laissent pas faire une analyse plus détaillée de ce cas important.  Figure 6. Algorithme mmCdgPars  Certes, il y a des grammaires où l'expression des dépendances non bornées ne pose pas problème, e.g. HPSG (Pollard & Sag, 1988), les extensions multimodales des grammaires de Lambek (Morrill, 1994; Moortgat, 1997), dont certaines visent notamment les dépendances (Kruijff, 2001) et leur fournissent une interface compositionnelle avec la sémantique. Or, l'analyse avec ces formalismes expressifs est très complexe et parfois nécessite l'utilisation des systèmes de démonstration des théorèmes. C'est aussi le cas des grammaires qui représentent P T IM E, dont RCG (Boullier, 2003). A la différence de mmCDG, ces grammaires n'ont pas d'algorithme universel d'analyse en temps O(n ), où k dépend de l'alphabet. Cela concerne aussi les grammaires basées sur l'unification et les contraintes, e.g. (Duchier, 1999). Contrairement à ces formalismes, les mmCDG n'utilisent que les moyens primitifs d'une complexité faible. E.g., les Grammaires Topologiques de Dépendances (Duchier & Debusmann, 2001) (voir aussi (Bröker, 1998; Duchier et al., 2004)) utilisent les hierarchies des domaines de l'ordre des mots (WO-domains) qui, en cas de discontinuité, servent à exprimer les contraintes de contiguïté, de distance entre un gouverneur et son modifieur etc. Dans beaucoup des cas, ces contraintes sont exprimées dans mmCDG par le moyen de sous types d'ancrage placés dans les positions correspondantes d'un type du gouverneur. Les mmCDG représentent une alternative intéressante aux TAG (et équivalentes : CCG, HG (Vijay-Shanker & Weir, 1994)) et aux grammaires faiblement contextuelles (Joshi et al., 1991), telles multi-TAG, non contextuelles multi-composantes, minimalistes, etc. Tout comme ces dernières, les mmCDG disposent d'une analyse syntaxique en temps polynomial. On peut même constater, qu'en pratique l'algorithme mmCdgPars va avoir une complexité O(n ). Leur avantage décisif est l'architecture compositionnelle de dépendances où toutes les dépendances, projectives comme non bornées, sont définies par les types fonctionnels, ce qui crée la base nécessaire pour une sémantique fonctionnelle de dépendances. En même temps, cette architecture adopte naturellement la multimodalité des dépendances non bornées correspondant aux règles de saturation des valences spécifiques aux différentes langues. Il est important de noter que cette flexibilité syntaxique est atteinte sans explosion du coût de l'analyse syntaxique (par contraste avec les grammaires de Lambek). Malgré leur simplicité, les mmCDG sont très expressives. On a vu que pour exprimer les dépendances croisées illimitées on n'a pas besoin du langage de copies, mais d'un langage des SD facilement exprimé par les mmCDG. Et le fait que M IX est un langage mmCDG montre que ces grammaires sont adaptées aux langues naturelles avec l'ordre des mots flexible. Enfin, il est difficile de comparer les mmCDG par l'expressivité avec les autres GD qui traitent les dépendances non bornées et qui les analysent en temps polynomial, e.g. (Kahane et al., 1998; Bröker, 2000). Le pouvoir de ces grammaires n'est pas déterminée. Leurs définitions sont opérationnelles (cf. le « lifting »). L'avantage des mmCDG est leur transparence et leur architecture compositionnelle de dépendances.  
