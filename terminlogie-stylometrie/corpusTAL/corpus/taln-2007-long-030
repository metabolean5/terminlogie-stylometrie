La notion d'arbre de dérivation dans les grammaires d'arbres adjoints (TAG) (Joshi & Schabes,  1997; Abeillé, 1993) est censée représenter les dépendances entre les différents items lexicaux d'une phrase. À ce titre, l'arbre de dérivation apparaît comme le candidat privilégié pour réaliser le transfert structurel entre la syntaxe et la sémantique de manière compositionnelle. Or, sa représentation ne rendant pas explicite certains liens, il a été proposé, afin de le rendre opérationnel dans le cadre du calcul de la représentation sémantique, soit de l'étendre (Kallmeyer, 2002; Joshi et al., 2003), soit de ne pas l'utiliser et de calculer la représentation sémantique directement sur l'arbre dérivé (Frank & van Genabith, 2001; Gardent & Kallmeyer, 2003; Gardent, 2007).  Cet article propose d'utiliser la notion d'arbre de dérivation telle qu'introduite dans (Pogodalla,  2004). En effet, cette notion, qui précise simplement la notion originale, y est montrée comme adéquate pour la représentation des dépendances longue distance. Néanmoins, le langage de représentation sémantique qui est utilisé est un formalisme sous-spécifié. Ces derniers posent parfois problème, comme dans le cas de la coordination de groupes nominaux quantifiés (Willis, 2007). De plus, nous voulons un cadre général qui laisse à l'utilisateur le choix d'utiliser ou  non de tels formalismes, tout en gardant la possibilité de modéliser les ambiguïtés. Ainsi, nous  utilisons un formalisme plus proche de celui proposé par Montague (Montague, 1974) et une architecture qui permet de traiter des phénomènes d'ambiguïté. Nous nous appuyons sur les Grammaires Catégorielles Abstraites (ACG) (de Groote, 2001), et, tout en gardant un seul arbre dérivé, nous montrons comment le principe d'élévation de type des grammaires catégorielles permet d'obtenir plusieurs lectures sémantiques.  Dans les deux prochaines sections, nous présentons l'arbre de dérivation de (Pogodalla, 2004)  sur des exemples. Puis nous définissons dans la section 4 la notion d'ACG et les architectures qu'elle rend possible pour l'interface entre la syntaxe et la sémantique. La section 5 met finalement en oeuvre une telle architecture pour modéliser l'ambiguïté de portée des quantificateurs.  La présentation habituelle des arbres élémentaires des TAG en donne une vision relativement  statique, les opérations de substitution et d'adjonction se chargeant de donner la dynamique du langage en combinant selon certaines règles les arbres entre eux. Dans cette section, nous nous proposons d'intégrer cette notion de dynamique aux arbres élémentaires eux-mêmes, en décrivant comment chacun prend part aux opérations de substitution et d'adjonction. Cette description se fait sur base d'exemples.  Soit l'arbre auxiliaire suivant :  N  un  N . Lorsqu'il est adjoint à un autre arbre à un noeud N ,  cet arbre remplace son propre noeud N  par le sous-arbre de racine N . Si l'on appelle x ce sousarbre, on peut donc considérer l'arbre auxiliaire comme une fonction qui transforme un arbre x en un nouvel arbre N  un  x . Soit, avec la notation à l'aide du -calcul, une représentation  de cet arbre par le terme suivant :   c  = x. N  un  x  Considérons maintenant l'arbre initial suivant : N   chat  . Cet arbre peut se voir adjoindre un arbre  auxiliaire au noeud N. Dans ce cas, il donnera comme argument à cet arbre auxiliaire (on a vu  que l'arbre auxiliaire peut être décrit comme étant une fonction qui prend un arbre en argument et retourne un arbre) le sous arbre N  chat  (dans le cas présent, le sous-arbre paramètre est l'arbre  tout entier car l'adjonction a lieu au noeud racine).   On peut donc représenter l'arbre initial comme une fonction qui prend comme paramètre un  arbre auxiliaire, c'est-à-dire une fonction des arbres dans les arbres. Soit, avec la notation en  -calcul : a.a ( N  chat  )  On constate alors que l'opération d'adjonction qui permet d'obtenir l'arbre  N  un  N  chat  est  décrite par l'application de la fonction (du terme) c  au terme c . En effet :  c  c = (a.a( N  chat  ))(x. N  un  x )  (x. N  un  x )( N  chat  )  N  un  N  chat   On peut finalement avoir un arbre qui combine la possibilité de subir une adjonction et une  substitution. Prenons par exemple l'arbre initial suivant : S  N   VP  dort  . Sa particularité est qu'il  attend un arbre qui peut être substitué au noeud N d'une part, et qu'il peut subir une adjonction  au noeud VP. On choisit donc de le représenter comme une fonction qui prend en premier argument un arbre auxiliaire, c'est-à-dire une fonction, et en deuxième argument un arbre x qui est celui qui est substitué au noeud N. On peut alors le représenter de la manière suivante :  c  = ax. S  x  a ( VP )  dort   Bien entendu, il est possible qu'aucune adjonction n'ait lieu sur le noeud VP  . Dans l'optique que nous avons choisie, cela signifie que la fonction qui a été adjointe est l'identité I = x.x.  L'arbre dérivé  S  N   un  N  chat  VP  dort  est alors représenté par le terme c I (c c ).  Avec  une représentation adéquate de l'adverbe, par exemple c = x. VP  x  paisiblement , on peut également construire l'arbre dérivé représenté par le terme  c  c (c c ) :  S   N   un  N  chat  VP  VP   dort  paisiblement  Si l'on appelle  le type des arbres, on voit que l'on a les constantes et le typage suivants :   c  :   c : (  )  c : (  )   c :   I :    où  désigne l'implication linéaire .  En typant les constantes représentant les arbres auxiliaires et initiaux de cette manière, nous  perdons toutefois une information importante : les arbres ont tous le même type , et aucune distinction n'est faire entre eux. Ainsi, la composition c c serait tout à fait licite. C'est pourquoi nous allons donner aux constantes un type plus abstrait , correspondant aux non-terminaux qui étiquettent leur racine. Nous nous donnons donc les types de base suivants : VP, S, V, N ainsi que les types qui correspondent aux racines des noeuds auxiliaires : VP , S , V , N .  Ainsi, en reprenant les exemples ci-dessus et en introduisant de nouvelles constantes, nous  avons les typages suivants :  C  : VP N S C : N N C : N C : VP I : VP  On peut alors avoir le terme C  I (C C ), de type S, tandis que le terme C C n'est pas typable. Il reste à établir le lien avec le terme c (c c ) de la section précédente. Cela se fait par une fonction de conversion := , le lexique, qui convertit les types et les constantes ainsi :  S  :=  VP :=  N :=  N :=   VP :=   C := c C := c C := c C := c I := x.x pour tout type X  On alors :  C I (C C ) := c I (c c ) et C C (C C ) := c c (c c )  Si l'on adopte une représentation arborescente des -termes (il n'y a pas d'abstraction), on peut  représenter C C (C C ) par :  C  C C C  Cet arbre rappelle très précisément l'arbre de dérivation tel qu'il est défini classiquement dans  les TAG. En fait, il s'agit de la même notion où sont cependant explicités : - l'ordre des arguments, qui doit être le même pour la constante qui est représentée dans l'arbre de dérivation et pour la constante qui lui est associée dans les arbres dérivés. Le choix est libre, mais une fois qu'il est fait, il doit être cohérent ; - l'ordre des adjonctions lors d'une dérivation. Contrairement à la notion classique, où cet ordre n'est pas précisé, le résultat étant le même, ici l'ordre des opérations est spécifié. Cela ne change pas le pouvoir expressif, cela permet par contre de doter les TAG d'une sémantique compositionnelle basée sur l'arbre de dérivation. Cette manière de représenter les arbres dérivés, les arbres de dérivation, et les relations qu'il y a entre eux, correspond en fait à la modélisation des TAG dans le formalisme des ACG.  Nous ne reprenons pas ici le détail la modélisation systématique des TAG dans les ACG, donné  dans (de Groote, 2002; Pogodalla, 2004). Nous allons simplement donner les définitions précises des ACG qui ont été mises en oeuvre dans les exemples précédents, afin d'en tirer l'architecture générale que nous utiliserons pour modéliser les ambiguïtés de portée des quantificateurs.  Une ACG définit deux langages : un langage abstrait, qui peut être vu comme un ensemble  abstrait de structures grammaticales, et un langage objet, représentant les formes réalisées des structures abstraites, qu'elle met en relation. Ici, le langage abstrait correspond à la structure grammaticale que l'on veut manipuler : l'arbre de dérivation. Dans l'exemple précédent, il est mis en relation avec le langage objet des arbres dérivés grâce au lexique.  Definition 1 (Signature d'ordre supérieur). Une signature d'ordre supérieure est un triplet   = A, C,  où : - A est un ensemble de types atomiques ; - C est un ensemble fini de constantes ; -  : C  T (A) qui assigne à chaque constante de C un type de T (A) où T (A) ::= A |T (A) T (A). On appel  l'ensemble des -termes que l'on peut construire avec la signature .  Ainsi, dans l'exemple précédent, nous avions deux signatures d'ordre supérieur. La première  contenait les types atomiques S, N, VP . . . et les constantes C , C . . . tandis que la deuxième signature d'ordre supérieur contenait l'unique type atomique  et les constante c , c . . .  Definition 2 (Lexique). Étant données une signature d'ordre supérieur   = A , C ,  et une signature d'ordre supérieur  = A , C ,  , un lexique := de  vers  est défini par la donnée de := et := tels que :  -  := : A  T (A ) est une fonction d'interprétation des types atomiques de  comme des types implicatifs construits à partir de A . On appellera := également son extension homomorphique à tous les types de T (A ) ; - := : C   est une fonction d'interprétation des constantes de  comme des -termes construits à partir de  . On appellera := également son extension homomorphique à tous les termes de  ; - les fonctions d'interprétation sont compatibles avec la relation de typage, c'est-à-dire que pour tout c  C et t :    tels que c := t, alors  (c) :=  (le type de l'image de c est l'image du type de c). Dans la suite, on utilisera sans ambiguïté := pour := ou :=.  Le tableau 1 définit bien un lexique. La colonne de gauche donne l'interprétation des types  atomiques (on remarquera avec l'interprétation du type VP que l'interprétation d'un type atomique peut être un type non atomique). La colonne de droite donne l'interprétation des constantes.  Definition 3 (Grammaire catégorielle abstraite). Une grammaire catégorielle abstraite est un  quadruplet G =  ,  , :=, s où : -  est une signature d'ordre supérieure, et  une signature d'ordre supérieure. Ils sont appelés vocabulaire abstrait et vocabulaire objet ; - := :    est un lexique ; - s est un type atomique du vocabulaire abstrait, appelé le type distingué de la grammaire.  Definition 4 (Langages abstrait et objet). Soit G =   ,  , :=, s une grammaire catégo- rielle abstraite. 1. Le langage abstrait A(G) engendré par G est défini par A(G) = {t   |t : s} 2. Le langage objet O(G) engendré par G est défini par O(G) = {t   |u  A(G) avec u := t}  Ainsi, les termes pris en exemple appartiennent bien aux vocabulaires abstrait et objet. Il est  à noter que cette définition permet d'éviter que le terme c (c c ), qui est bien un arbre (de type ), appartienne effectivement au langage objet des arbres dérivés. En effet, il serait l'image de C (C C ) qui n'est pas de type S (ce terme n'est même pas typable) et qui n'appartient donc pas au langage abstrait des arbres de dérivation.  La définition des ACG permet de considérer différents types d'architecture. Par exemple, si  deux ACG partagent le même vocabulaire abstrait, on aura le schéma de composition de la figure 1(a). C'est par exemple celui adopté dans (Pogodalla, 2004) pour doter les TAG d'une représentation sémantique sous-spécifiée. On peut également composer deux ACG en faisant que le vocabulaire objet de l'une soit également le vocabulaire abstrait de l'autre (figure 1(b)). C'est par exemple le cas si l'on veut considérer le lien entre les arbres dérivés, cette fois vus comme un langage abstrait, et leur production (yield en anglais) comme langage de chaîne.  Bien entendu, on peut mélanger ces deux types de composition. La modélisation que nous  proposons pour les phénomènes d'ambiguïté de portée des quantificateurs repose sur le schéma de la figure 1(c). Dans tous les cas, on retrouve un schéma classique du TAL, même si la relation est décrite par un autre formalisme : celui de la composition de transducer.  Proposition.  Notre objectif est de proposer pour les TAG un cadre dans lequel modéliser les ambiguïtés de portée sans utiliser de formalisme sous-spécifié (contrairement à (Pogodalla, 2004)), tout en gardant la contrainte d'avoir un unique arbre dérivé auquel peuvent être associées plusieurs représentations sémantiques. Pour l'architecture que nous proposons, il nous faut définir deux nouvelles ACG. La première, G , permettra d'associer à un arbre de dérivation unique deux structures plus profondes. La seconde, G , correspondra à la réalisation dans un langage de formes logiques du type de Montague de ces structures plus profondes. On pourra penser que ces différents niveaux ajoutent de la complexité conceptuelle. Nous pensons pour notre part que cela permet de modulariser les difficultés (en ne traitant qu'à leurs niveaux respectifs la syntaxe, avec G , et la sémantique, avec G et G ). Par ailleurs, nous avons vu que cette notion de composition est déjà présente en TAL avec l'utilisation de transducer et de leur composition, pour le traitement de la morphologie par exemple. Si au final seule la relation entre les langages d'entrée et sortie nous intéresse, il est tout à fait possible de compiler deux ACG, par exemple G et G en une seule, leur composée.  Supposons que la grammaire G  contiennent également les arbres suivants : c = axy. S  x  a ( VP )  chasse  y , c = a.a( N  chien  ) et c = x. N  tout  x , ainsi que les  constantes C  : N N, C : VP N N S et C : N mis en relation par le lexique de la manière suivante : C := c , C := c et C := c .  Alors l'arbre de dérivation correspondant à l'arbre dérivé   c  (c c )(c c ):= S  N   tout  N  chien  VP  chasse  N  un  N  chat   est t  = C I (C C )(C C ).  Définissons maintenant G  , dont le vocabulaire objet est le vocabulaire abstrait de G , et dont le vocabulaire abstrait contient les mêmes symboles de type que le vocabulaire objet mais les constantes typées D : VP N N S, D : N (N S) S, D : N (N S) S, D : N , D : N et I : VP . Le lexique := est tel que pour tout type X, X:= X et :  D  := C D := C D := C D := aP.P (C a ) D := aP.P (C a ) I := I  Soit alors les termes :   t  = (D D )(x.(D D )(y.D I x y )) t = (D D )(y.(D D )(x.D I x y ))  On pourra vérifier que t  et t sont bien typés et que t := t et t := t . Ainsi, nous avons désormais deux structures profondes (t et t ) reliées à un seul arbre de dérivation (t ).  Il nous reste à transformer ces structures en formules logiques à l'aide d'une nouvelle ACG  G . Celle-ci partage son vocabulaire abstrait avec G , et, au niveau objet, met en oeuvre les types habituels e et t pour les représentations à la Montague. Avec le lexique := suivant :  S  := t N := e N := (e  t)  (e  t)  t VP := (e  t)  (e  t) D := aso. (a(x.chasse x o))s D := P Q. x.P x  Q x D := P Q. x.P x  Q x D := q.q (x.chat x) D := q.q (x.chien x) I := x.x  Nous laissons le lecteur vérifier que l'on obtient bien alors les deux lectures :   t  := x.chien x  (y.chat y  chasse x y) t := y.chat y  (x.chien x  chasse x y)  Faute de place, nous ne pouvons illustrer également la coordination de groupes nominaux  quantifiés avec les constantes C : N N N, D : ((N S) S) ((N  S)  S) ((N S)  S) et leur réalisation D := P Qr.P (x.Q(y.r(C x y ))) et D := P Qr.P r  Q r. On aurait par exemple les deux termes  t  = D (D D )(D D )(x.(D D )(y.D I x y )) t = (D D )(y.D (D D )(D D )(x.D I x y ))  qui donneraient les deux lectures attendues pour tout chat et un chien chassent une souris.  Contrairement au problème soulevé par les représentations sous-spécifiées dans (Willis, 2007), on n'a pas la lecture où tout chat a une portée différente de un chien vis à vis de la portée de une souris. On obtient ainsi une architecture dans laquelle modéliser les phénomènes d'ambiguïté de portée sans imposer l'utilisation de formalismes sous-spécifiés. Limitations. Actuellement, nous ne savons pas exprimer les contraintes de portée des quantificateurs, telles celles des îlots de portée. Ce problème est comparable à celui rencontré par les grammaires de types logiques. En effet, l'approche proposée ici repose sur le principe de l'élévation de type, qui est à la base de la prise en compte des ambiguïtés de portée dans ces grammaires. Ici, nous avons gardé la contrainte supplémentaire que, bien entendu, l'arbre dérivé et l'arbre de dérivation restent uniques. La solution que nous envisageons repose sur une extension du système de type des ACG, et va bien au-delà du sujet de cet article .  Nous avons montré comment, en se basant sur la définition précise de l'arbre de dérivation  de (Pogodalla, 2004), nous pouvons définir un calcul des représentations sémantiques pour les TAG qui ne nécessite pas l'usage de formalismes sous-spécifiés tout en permettant le traitement de l'ambiguïté. Cela nous permet d'une part de renforcer l'indépendance entre le formalisme syntaxique des TAG et le formalisme choisi par l'utilisateur pour la représentation sémantique, et d'autre par de confirmer l'importance de cette notion d'arbre de dérivation. Par ailleurs, notre approche a de forts liens avec les approches de Glue Semantics (Dalrymple, 2001), et la proposition (Frank & van Genabith, 2001) (utilisant les principes de Glue Semantics depuis l'arbre dérivé) pourrait sans doute être reconsidérée avec cette notion d'arbre de dérivation.  
