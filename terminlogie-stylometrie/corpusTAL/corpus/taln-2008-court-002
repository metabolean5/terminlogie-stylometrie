Nous définissons un formalisme, les grammaires rationnelles d'arbres avec traits, et une traduction des grammaires d'arbres adjoints avec traits vers ce nouveau formalisme. Cette traduction préserve les structures de dérivation de la grammaire d'origine en tenant compte de l'unification de traits. La construction peut être appliquée aux réalisateurs de surface qui se fondent sur les arbres de dérivation. The derivation trees of a tree adjoining grammar provide a first insight into the sentence semantics, and are thus prime targets for generation systems. We define a formalism, feature based regular tree grammars, and a translation from feature based tree adjoining grammars into this new formalism. The translation preserves the derivation structures of the original grammar, and accounts for feature unification. Unification, grammaire d'arbres adjoints, arbre de dérivation, grammaire rationnelle d'arbres. Unification, tree adjoining grammar, derivation tree, regular tree grammar.  Le processus de dérivation dans les grammaires d'arbres adjoints (Joshi & Schabes, 1997, TAG)  produit deux arbres : l'arbre dérivé qui correspond à un arbre syntagmatique classique (voir figure 1b), et l'arbre de dérivation, qui présente par quelles opérations les arbres élémentaires de la grammaire ont été combinés pour obtenir l'arbre dérivé (voir figure 1a). Selon la tâche de traitement de la langue, il sera plus adéquat de considérer l'un ou l'autre, l'arbre dérivé étant en correspondance avec les lexèmes d'une phrase, tandis que l'arbre de dérivation donne une vue sémantique primitive de la phrase, comme le montrent par exemple Candito & Kahane (1998).  De fait, l'arbre de dérivation est privilégié dans plusieurs approches pour la réalisation de  surface (Koller & Striegnitz, 2002; Koller & Stone, 2007). Il sert aussi de pivot à partir duquel représentation sémantique et arbre dérivé peuvent être générés dans les approches de de Groote (2002), Pogodalla (2004) et Kanazawa (2007) à base de grammaires catégorielles abstraites.  Ces travaux ne sont cependant pas immédiatement applicables à des grammaires réalistes qui  emploient une variante des TAG à base de structures de traits (Vijay-Shanker, 1992, voir par exemple la figure 2). Cette variante munit les noeuds des arbres élémentaires de structures de traits, dont les unifications contraignent les opérations de substitution ou d'adjonction du noeud.  radis   gris   le  creux  est  S  N   Adj  N N  radis gris  D  le  Adj  creux  est V VP [ ]  N  N  D   le  Adj  gris  N  N  radis N  VP  S  N   Adj  V  creux  V  est  [ ] [ ] [ ]  Ces structures ne posent en théorie aucun problème, car les domaines de valeur des différents  traits sont finis et il suffit de démultiplier le nombre de symboles non-terminaux pour émuler les différentes structures possibles. Mais le nombre de ces structures s'accommode mal de cette vision naïve : par exemple, les vingt-huit traits syntaxiques utilisés dans la grammaire S F G du français (Gardent, 2006) décrivent un domaine, certes fini, mais comprenant plus de 214 milliards d'éléments. Enfin, l'argument du domaine fini ne tient tout simplement pas pour certains mécanismes de construction sémantique fondés sur l'unification de traits d'index sémantiques qui ont des domaines de valeur non finis (Gardent & Kallmeyer, 2003; Gardent, 2006).  Nous étudions dans cet article la traduction d'une grammaire d'arbres adjoints avec structures  de traits en une grammaire rationnelle d'arbres de dérivation qui en préserve les mécanismes d'unification de traits. Plus en détail, - nous rappelons comment traduire une grammaire TAG en une grammaire rationnelle d'arbres (RTG) qui en génère les arbres de dérivation (section 2.1), - puis nous définissons un formalisme de grammaires rationnelles d'arbres enrichies par des structures de traits et montrons comment traduire une grammaire TAG dans ce nouveau formalisme (section 2.2) ; - enfin, nous proposons une seconde traduction qui améliore l'efficacité de la génération des arbres de dérivation TAG (section 3). Nous supposons que le lecteur est familier avec les aspects théoriques des grammaires d'arbres adjoints (Joshi & Schabes, 1997), des grammaires rationnelles d'arbres (Comon et al., 2007) et de l'unification (Robinson, 1965) .  Un arbre de dérivation d'une grammaire d'arbres adjoints a des noeuds étiquetés par des arbres  élémentaires de la grammaire et en guise d'arêtes les relations d'adjonctions et substitutions permises par la grammaire entre arbres élémentaires. Dans un premier temps, nous reformulons la description donnée par de Groote (2002) des arbres de dérivation qu'une grammaire d'arbres adjoints peut engendrer, en utilisant explicitement une grammaire rationnelle d'arbres. Dans un second temps, nous montrons comment les calculs d'unification de l'arbre dérivé peuvent s'intégrer simplement dans cette grammaire rationnelle.  Formellement, une grammaire d'arbres adjoints , N, I, A, S est constituée d'un alphabet  terminal , d'un alphabet non-terminal N , d'un ensemble I d'arbres initiaux , d'un ensemble A d'arbres auxiliaires , et d'un non-terminal distingué S de N . Nous désignons par  le noeud racine de l'arbre élémentaire  et par  le noeud pied de l'arbre auxiliaire . Les noeuds d'un arbre élémentaire  de I  A qui nous intéressent sont étiquetés par des nonterminaux, et permettent une opération de substitution ou d'adjonction ; nous considérons en particulier que le pied d'un arbre auxiliaire ne permet pas d'adjonction . Nous numérotons ces noeuds par un parcours arbitraire depuis la racine, de sorte que  =  . Nous notons lab( ) l'étiquette dans N du noeud  .  Pour construire la grammaire rationnelle S, N  N  , F , R des arbres de dérivation, nous définissons : - l'ensemble des arbres élémentaires comme notre alphabet ordonné F = I  A  {}, où le rang n = rg() d'un arbre élémentaire  est le nombre de ses noeuds où une substitution ou une adjonction est possible, et où , de rang 0, représente une feuille vide ; - l'alphabet non-terminal N et un duplicata N = {X | X  N } comme alphabet de la grammaire rationnelle ; à chaque noeud non terminal  d'un arbre étiqueté par X = lab( ), on associe un non terminal nt( ) de forme X dans N s'il permet une substitution ou X dans N s'il permet une adjonction ; - l'ensemble de règles R défini comme l'union  {X    (nt( ), . . . , nt( )) |   I, n = rg(), X = lab( )}  {X   (nt( ), . . . , nt( )) |   A, n = rg(), X = lab( )}  {X    | X  N } (1)  Les arbres initiaux de la grammaire TAG sont ainsi associés à des règles de la forme  X   (Y , . . . , Y ) et les arbres auxiliaires à des règles X   (Y , . . . , Y ), où X est le non terminal qui étiquette la racine de l'arbre élémentaire TAG. Enfin, la possibilité d'une adjonction non réalisée est simulée par les règles X   . On peut observer que la taille de la grammaire RTG obtenue est équivalente à la taille de la grammaire TAG d'origine. La traduction elle-même peut être calculée en temps linéaire.  Puisque la grammaire TAG de la figure 2 ne propose pas d'arbre auxiliaire enraciné par S, VP ,  Adj ou D, on peut simplifier les règles en ignorant ces noeuds d'adjonction. La figure 3a montre  S, {S, V, V  , N, N }, {creux, est, radis, gris, le, }, {S   creux(N, V ), V   est(V ), V   , N   radis(N ), N   gris(N ), N   le(N ), N   } gris  gris     radis est creux  radis     est creux       le  le   le  radis est creux  la grammaire simplifiée pour les arbres de la figure 2. Il est aisé de vérifier que cette grammaire  rationnelle génère les arbres enracinés par « creux », avec « radis » et « est » pour deux fils, et une combinaison arbitraire de noeuds « le » et « gris » comme descendance de « radis » (voir figure 3b) : la grammaire rationnelle génère les arbres de dérivation d'une version sans structures de traits de la grammaire TAG d'origine.  Grammaire rationnelle d'arbres avec traits  Afin de traduire les restrictions imposées par les structures de traits de la grammaire TAG, nous considérons dans notre RTG non plus de simples réécritures entre termes, mais des surréductions (Hanus, 1994), c'est-à-dire des réécritures assorties d'unifications, avec des variables dans (N  N ) × D où D désigne l'ensemble des structures de traits possibles .  Definition 1. Une grammaire rationnelle d'arbres avec traits S, N, F , D, R est composée  d'un axiome S, d'un ensemble de symboles non-terminaux N contenant S, d'un alphabet ordonné de terminaux F , d'un ensemble de structures de traits D, et d'un ensemble de règles de forme (A, d)   a((B , d ), . . . , (B , d )) avec A, B , . . . , B des non-terminaux de N , d, d , . . . , d des structures de traits de D, et a un terminal d'arité n de F .  La relation de dérivation =   associée à G = S, N, F , D, R met en relation des paires associant un terme de T (F , N × D) et une u-substitution, de telle sorte que (s, e) =  (t, e ) si et seulement s'il existe un contexte C, une règle (A, d)   a((B , d ), . . . , (B , d )) dans R avec des variables fraîches dans les structures d, d , . . . , d et une u-substitution  tels que  s = C[(A, d )],  = mgu(d, e(d )), t = C[a((B  , (d )), . . . , (B , (d )))] et e =   e  Le langage généré par G est L(G) = {t  T (F ) | e, ((S,  ), id ) =  (t, e)}. La propagation des unifications de traits se fait hiérarchiquement par la recherche de l'unificateur le plus général mgu à chaque étape de dérivation. L'u-substitution e globale associée comme environnement à notre terme sert à communiquer les résultats des unifications dans les différentes branches du terme.  Traduction de TAG vers RTG avec traits  Munis de cette définition opérationnelle d'une RTG avec unification, nous enrichissons notre traduction de TAG vers RTG pour tenir compte des structures de traits des noeuds des arbres TAG. Nous définissons feats( ) comme la structure de traits de D associée au noeud  de l'arbre élémentaire . Cette structure est composée de deux ensembles hauts et bas de traits atomiques top( ) et bot( ).  La traduction est établie sur la notion d'interface in() offerte par chaque arbre élémentaire TAG  , qui servira de structure de traits de la partie gauche des règles de la grammaire rationnelle d'arbres avec traits. Dans le cas d'un arbre initial , la structure [top : top( )] doit s'unifier avec celle du noeud de substitution. Dans le cas d'un arbre auxiliaire , la structure [top : top( ), bot : bot( )] doit s'unifier avec celle du noeud d'adjonction. Il reste à coindexer ces interfaces avec les structures de la partie droite de chaque règle ; le seul cas à traiter est celui de la racine de l'arbre élémentaire, pour laquelle nous définissons une fonction feats . Nous définissons ainsi pour tout  dans I,  dans A et  dans I  A, à l'aide d'une variable fraîche t  in() =  (2)  in() =  (3)  feats  ( ) = (4)  Pour un noeud   , nous définissons tr( ) = (nt( ), feats( )) et tr ( ) = (nt( ), feats ( )). L'ensemble de règles de notre grammaire rationnelle d'arbres avec traits pour une grammaire TAG , N, I, A, S est alors  {(X, in())    (tr ( ), tr( ), . . . , tr( )) |   I, n = rg(), X = lab( )}  {(X , in())   (tr ( ), tr( ), . . . , tr( )) |   A, n = rg(), X = lab( )}  {X    | X  N , x variable de D} (5)  Les règles dérivant la feuille vide  effectuent l'unification finale entre traits hauts et bas des  noeuds de la grammaire TAG.  Nous obtenons alors l'ensemble de règles suivant pour la grammaire rationnelle enrichie de  structures de traits correspondant à la grammaire TAG de la figure 2 :  (S,  )   creux N , V [ ] V [ ]   est V V     N [  ]   radis N N   gris N  N    le N  N     (6)  Exemple de dérivation  Nous reprenons dans la figure 4 le cas de la phrase « Le radis gris est creux. » en employant les règles enrichies de structures de traits de l'équation (6). Chaque noeud de l'arbre de la figure est constitué d'une étiquette et d'un couple formé d'un terme de T (F , (N  N ) × D) et d'un environnement . La création de variables fraîches utilise l'adresse de Gorn du noeud où la réécriture a lieu. Les étiquettes de chaque noeud indiquent l'ordre dans lequel s'effectuent les surréductions. Enfin, l'on remplace les variables par leur valeur associée dans l'environnement dès que possible.  On ne peut pas dériver l'arbre correspondant à « * Le radis gris sont creux. ». La partie gauche  de la tentative de dérivation aurait été similaire. En revanche, dans la partie droite, le trait bot associé au noeud V de sont aurait eu pour valeur num : pl (pluriel). L'analyse aurait donc échoué à l'étape suivante, puisqu'en atteignant la feuille  il aurait fallu unifier des traits top et bot avec respectivement sg et pl comme valeurs de num.  Bien sûr, pour une analyse qui visite d'abord le sous-arbre droit avant le sous-arbre gauche,  le résultat serait le même, avec encore pour étape décisive du point de vue de l'unification la réécriture finale à .  Comme nous venons de le voir, la génération d'un arbre de dérivation TAG à l'aide d'une  grammaire RTG avec traits n'est pas très prédictive, dans le sens où il est nécessaire de patienter jusqu'à la réécriture à  pour vérifier si une substitution réussit. Dans l'exemple de la figure 4, la substitution de « radis » dans « creux » n'est véritablement entérinée qu'au moment de la réécriture à , et potentiellement toutes les opérations intermédiaires seraient à défaire si cette réécriture n'avait pas été possible.  Le seul filtrage immédiatement exercé par l'arbre « radis » lors de sa substitution au noeud N  de « creux » est l'unification de sa structure top avec la structure top de N . Or, l'arbre « radis »  suit l'usage dans les grammaires TAG, qui est que sa structure top est vide, et il n'y a en fait  aucun filtrage par ce biais.  Nous présentons dans cette section une transformation du langage d'arbres de dérivation qui  permet d'inverser l'ordre des réécritures, en commençant par , en opérant à toutes les adjonctions à la racine, et en finissant par l'arbre initial. Comme nous avons convenu que la racine d'un arbre élémentaire TAG apparaissait en fils gauche dans nos arbres de dérivation, cette transformation revient à une transformation par coin gauche (Rosenkrantz & Lewis II, 1970) appliquée à nos grammaires rationnelles d'arbres de dérivation. Cette transformation est simple, et nous semble plus naturelle que la transformation correspondante sur les arbres dérivés.  Les règles que nous souhaitons transformer sont de la forme X    (X , . . . ), X   (X , . . . ) ou X   . À l'issue de la transformation, un appel à X devra commencer par invoquer , puis les adjonctions  en ordre inverse, et enfin  en dernier lieu, dont l'arité est décrémentée. Pour notre grammaire (figure 3a), cela revient simplement à utiliser de nouveaux non-terminaux N et V et les règles S   creux(N , V ) N   (N ) N   radis | gris(N ) | le(N ) V   (V ) V   est (7)  Il manque à ces règles la possibilité d'une adjonction ailleurs qu'à la racine d'un arbre initial ;  il suffit alors de conserver les règles X   (X , . . . ) et X    qui s'appliqueront comme auparavant.  Nous pouvons ensuite éliminer les -termes ; la grammaire de la figure 3a transformée est alors :   S    creux(N, V ) N   radis | gris(N ) | le(N ) N   gris(N ) | le(N ) |  V   est (8)  Les règles de dérivation de N  sont cependant inutiles puisqu'il n'y a jamais d'adjonction sur un noeud de catégorie N qui n'est pas une racine dans notre grammaire d'arbres adjoints. Formellement, étant donnée une grammaire d'arbres adjoints , N, I, A, S , sa grammaire rationnelle d'arbres de dérivation transformée par coin gauche G = S, N  N , F , R utilise un alphabet terminal F = I  A  {} mais où l'arité d'un arbre initial  est rg()  1, et un ensemble de règles R défini comme l'union  {X    (nt( ), . . . , nt( )) |   I, n = rg(), X = lab( )}  {X   (X, nt( ) . . . , nt( )) |   A, n = rg(), X = lab( )}  {X   (nt( ), . . . , nt( )) |   A, n = rg(), X = lab( )} (9)  La taille de cette grammaire est au pire doublée par rapport à la grammaire rationnelle d'arbres  de dérivation puisque chaque arbre auxiliaire apparaît maintenant deux fois. En pratique, les règles utiles dans la grammaire obtenue sont probablement moins nombreuses. Par exemple,  dans la grammaire S  F G et en se basant sur l'existence de noeuds d'adjonction ailleurs qu'à la racine pour chaque catégorie syntaxique, seuls un tiers des arbres auxiliaires, soit encore un dixième des arbres élémentaires, est concerné par cette duplication. Notons enfin que la transformation est aisément réversible. Nous définissons pour cela la fonction lc de T (F ) dans T (F ) par  lc  (t) = revlc(t, ) (10) revlc((t , t , . . . , t ), t) = revlc(t , (t, f (t ), . . . , f (t ))) (11) revlc((t , . . . , t ), t) = (t, f (t ), . . . , f (t )) (12)  f  (t) = recur(t) si  est un noeud d'adjonction lc (t) si  est un noeud de substitution (13)  recur((t  , . . . , t )) = (f (t ), . . . , f (t )) (14)  On peut ainsi procéder à la génération d'un arbre dérivé dans L(G  ) et retrouver l'arbre correspondant de L(G) en lui appliquant lc .  Nous procédons maintenant à la définition d'une grammaire rationnelle d'arbres de dérivation  transformée par coin gauche avec structures de traits. En reprenant les règles transformées (7) de la section 3.1, nous obtenons dans un premier temps les règles transformées avec structures de traits (S, )   creux N , V [ ]  N  [ ]    N N [ ]   radis  N    gris N  N    le N  V  [ ]    V V [ ]   est (15)  Comme la récursion au sein des arbres auxiliaires est inversée, les structures de traits de la  partie gauche de chaque règle sont les structures de son noeud racine dans la grammaire TAG, et inversement (on observe ce changement pour la règle qui dérive « le »).  Nous pouvons comme auparavant éliminer les règles dérivant , ce qui a pour effet de copier la  structure de traits top des noeuds de substitution dans la structure bot . Nous obtenons l'ensemble de règles suivant pour la grammaire TAG de la figure 2 :  (S,  )   creux N , V N [ ]   radis  N    gris N  N    le N  V [  ]   est (16)  Cette grammaire d'arbres avec traits est bien plus lisible que celle décrite dans l'équation (6) :  le premier fils de « creux » ne peut être que « le » de par la présence du trait det = + dans la structure bot associée à N . Les seuls fils de « le » possibles sont « gris » et « radis », seuls compatibles avec le trait det = . Le filtrage dû aux unifications est maintenant immédiat.  Construction de la grammaire rationnelle transformée  Nous définissons les variantes suivantes des fonctions de calcul de structures de traits, pour tout arbre auxiliaire  de A et pour tout noeud  d'un arbre élémentaire  de I  A :  in  () = (17)  feats  ( ) =          si  est un noeud de substitution, si  =  ,  feats(  ) sinon. (18)  Pour un noeud   , nous notons tr ( ) la paire (nt( ), feats ( )). Formellement, l'ensemble de règles de notre grammaire rationnelle d'arbres avec traits transformée pour une grammaire TAG , N, I, A, S est alors  {(X, feats(  ))   (tr ( ), . . . , tr ( )) |   I, n = rg(), X = lab( )}  {(X, feats ( ))   ((X, in ()), tr ( ), . . . , tr ( )) |   A, n = rg(), X = lab( )}  {(X , in())   (tr ( ), tr ( ), . . . , tr ( )) |   A, n = rg(), X = lab( )} (19)  Les grammaires rationnelles d'arbres avec structures de traits permettent de générer aisément les  arbres de dérivation d'une grammaire TAG avec structures de traits. Les grammaires transformées par coin gauche permettent de plus de filtrer plus efficacement les opérations d'adjonction et de substitution possibles à partir d'un arbre élémentaire. Si des calculs d'unification sur arbres de dérivation ont déjà été considérés par le passé de manière spécialisée (Kallmeyer & Romero, 2004), les mécanismes que nous avons définis sont suffisamment généraux pour traduire fidèlement l'unification dans les grammaires d'arbres adjoints.  Parmi les perspectives ouvertes par ce traitement des structures de traits dans les arbres de  dérivation, on pourra mentionner des calculs d'accessibilité plus fins entre les arbres élémentaires, utiles par exemple pour vérifier qu'une TAG est dans la classe restreinte des grammaires d'arbres par insertion (Schabes & Waters, 1995, TIG) ou sous forme rationnelle (Rogers, 1994, RFTAG). On pourrait par ailleurs imaginer étendre notre approche à l'analyse syntaxique, pour peu que les informations topologiques d'ordre entre les ancres soient calculées dans nos arbres de dérivation (Kuhlmann, 2007).  
