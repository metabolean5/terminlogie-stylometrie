Cet article étudie la relation entre les grammaires d'arbres adjoints à composantes multiples avec tuples d'arbres (TT-MCTAG), un formalisme utilisé en linguistique informatique, et les grammaires à concaténation d'intervalles (RCG). Les RCGs sont connues pour décrire exactement la classe PTIME, il a en outre été démontré que les RCGs « simples » sont même équivalentes aux systèmes de réécriture hors-contextes linéaires (LCFRS), en d'autres termes, elles sont légèrement sensibles au contexte. TT-MCTAG a été proposé pour modéliser les langages à ordre des mots libre. En général ces langages sont NP-complets. Dans cet article, nous définissons une contrainte additionnelle sur les dérivations autorisées par le formalisme TT-MCTAG. Nous montrons ensuite comment cette forme restreinte de TT-MCTAG peut être convertie en une RCG simple équivalente. Le résultat est intéressant pour des raisons théoriques (puisqu'il montre que la forme restreinte de TT-MCTAG est légèrement sensible au contexte), mais également pour des raisons pratiques (la transformation proposée ici a été utilisée pour implanter un analyseur pour TT-MCTAG). This paper investigates the relation between TT-MCTAG, a formalism used in computational linguistics, and RCG. RCGs are known to describe exactly the class PTIME ; « simple » RCG even have been shown to be equivalent to linear context-free rewriting systems, i.e., to be mildly context-sensitive. TT-MCTAG has been proposed to model free word order languages. In general, it is NP-complete. In this paper, we will put an additional limitation on the derivations licensed in TT-MCTAG. We show that TT-MCTAG with this additional limitation can be transformed into equivalent simple RCGs. This result is interesting for theoretical reasons (since it shows that TT-MCTAG in this limited form is mildly context-sensitive) and also for practical reasons (the proposed transformation has been used for implementing a parser for TT-MCTAG). Grammaires d'arbres adjoints à composantes multiples, grammaires à concaténation d'intervalles, légère sensibilité au contexte. Multicomponent Tree Adjoining Grammars, Range Concatenation Grammars, mild context-sensitivity.  Il a été démontré que les grammaires d'arbres adjoints (TAGs) sont d'un grand interêt pour  le traitement automatique des langues naturelles, et pour des raisons linguistiques (domaine de localité étendu), et pour des raisons formelles (complexité d'analyse). Pourtant, elles sont trop limitées dans leur expressivité pour traiter certains phenomènes linguistiques comme par exemple le brouillage d'arguments dans des langues dites à ordre des mots libre.  Cet article considère une variante des TAGs, les grammaires d'arbres adjoints à composantes  multiples avec tuples d'arbres (TT-MCTAGs), cherchant à résoudre ce problème d'expressivité tout en gardant les propriétés principales des TAGs. Dans ce contexte, nous traitons les propriétés formelles de ce formalisme, en particulier sa relation avec les langages legèrement sensibles au contexte. En donnant la construction d'une grammaire à concaténation d'intervalles (RCG) simple pour une TT-MCTAG qui satisfait une certaine contrainte, nous obtenons deux résultats : d'abord nous prouvons que ces TT-MCTAGs restreintes sont en fait légèrement sensibles au contexte. Ensuite, en combinant cette construction avec un analyseur pour RCG, nous pouvons développer un analyseur pour TT-MCTAG. Nous pensons que l'idée de passer par les RCGs pour analyser certains formalismes grammaticaux au lieu de développer un analyseur différent pour chacun d'entre eux peut être utile d'une façon générale.  Le plan de cet article est le suivant. Dans un premier temps, nous définissons les formalismes  sur lesquels nous nous basons, à savoir TAG (section 1.1) et RCG (section 1.2), et présentons brièvement un algorithme existant de conversion de TAG vers RCG (section 1.3). Ensuite, nous introduisons le formalisme des TT-MCTAGs (section 2), ainsi que leur forme restreinte. Finalement nous donnons l'algorithme de conversion de ces grammaires en RCG (section 3).  Les TAGs (Joshi & Schabes, 1997) sont des systèmes de réécriture d'arbres. Une TAG est un  ensemble fini d'arbres (les arbres élémentaires) avec des étiquettes non-terminales et terminales (les derniers seulement pour des feuilles). Des arbres plus grands sont générés par substitution (remplacement d'une feuille par un nouvel arbre) et adjonction (remplacement d'un noeud interne par un nouvel arbre). En cas d'adjonction, l'arbre que l'on adjoint a exactement une feuille marquée comme noeud pied (marquée par une étoile). Un tel arbre s'appelle un arbre auxiliaire. Si cet arbre est adjoint à un noeud n, alors dans l'arbre résultat, le sous-arbre de racine n s'attache au noeud pied de l'arbre auxiliaire. Des arbres non-auxiliaires s'appellent des arbres initiaux. Chaque dérivation commence par un arbre initial. Dans un arbre dérivé terminal, toutes les feuilles doivent avoir des étiquettes terminales. Un exemple est donné Fig. 1.  NP   John  S  NP  VP  V   laughs  VP ADV VP  always  arbre S dérivé : NP VP John ADV VP always V  laughs  arbre de : dérivation : laugh john always  Définition 1. Une TAG est un tuple  G = I, A, N, T avec (i) N et T des alphabets disjoints, les nonterminaux et les terminaux, et (ii) I et A des ensembles finis d'arbres initiaux et auxiliaires respectivement avec non-terminaux N et terminaux T . En outre, les noeuds internes dans I  A peuvent être marqués OA (adjonction obligatoire) ou NA (adjonction interdite).  Définition 2. Soient  G = I, A, N, T une TAG,  et  des arbres finis. -    dans G ssi il existe une adresse de noeud p et un arbre  qui est soit un arbre élé- mentaire, soit dérivé d'un arbre élémentaire tel que  = [p,  ] .  est la clôture réflexive et transitive de . - Le langage d'arbres de G est L (G) = { |    pour quelque   I, toutes les feuilles dans  ont une étiquette terminale et  ne contient pas de noeud marqué OA}.  Les dérivations en TAG sont représentées par des arbres de dérivation (des arbres non-ordonnés)  qui décrivent comment les arbres élémentaires ont été combinés. L'arbre dérivé est alors le résultat de l'exécution de ces combinaisons, i.e., l'arbre de dérivation décrit de façon unique un seul arbre dérivé. Chaque arc dans un arbre de dérivation représente une adjonction ou une substitution. Les arcs sont etiquetés avec des adresses de noeud de Gorn . L'arbre de dérivation de la Fig. 1 par exemple, indique que l'arbre élémentarire de John a été substitué au noeud d'adresse 1 et always a été adjoint à l'adresse 2 (le fait que le premier est une substitution, le deuxième une adjonction peut être déduit du fait que l'adresse 1 est l'adresse d'une feuille tandis que 2 est l'adresse d'un noeud interne).  Définition 3. Soit  G = I, A, N, T une TAG, on définit  un arbre dérivé d'un arbre élémen- taire  dans G comme suit :  =  [p ,  ] . . . [p ,  ] tel que les substitutions/adjonctions des  , . . . ,  sont les seules substitutions/adjunctions à  exécutées lors de la dérivation de . Dans ce cas-là, l'arbre de dérivation correspondant a une racine étiquetée  qui a k fils. Les arcs entre  et ces fils sont étiquetés p , . . . , p , et les fils sont les arbres de dérivation des dérivations de  , . . . ,  .  Définition 4. Une RCG positive (Boullier, 1999b; Boullier, 2000) est un tuple  G = N, T, V, S, P tel que (i) N est un ensemble fini de prédicats, chacun d'arité fixe, S  N (d'arité 1) le prédicat initial, (ii) T et V sont des alphabets disjoints de terminaux et de variables, et (iii) P est un ensemble fini de clauses de la forme : A (x , . . . , x )   ou A (x , . . . , x )  A (x , . . . , x ) . . .A (x , . . . , x ) avec n  1, A  N, x  (T  V ) et a l'arité d' A .  Notons qu'une RCG avec une arité maximale  n s'appelle une RCG d'arité n. Notons également que, dans ce papier nous n'utilisons que des RCGs positives, ainsi, dans ce qui suit, chaque mention des RCGs refère aux RCGs positives . Dans un appel de clause par rapport à une chaîne w = t . . . t , les arguments des prédicats sont instantiés par des sous-chaînes de w,  plus précisement par les intervalles correpondants. Un intervalle  i, j avec 0  i < j  n correspond à la chaîne entre les positions i et j, i.e., la chaîne t . . . t . Si i = j, i, j correspond à . Si i > j, i, j n'est pas défini.  Définition 5. Une instantiation d'une clause  C par rapport à une chaîne w = t . . . t est une fonction f : {t | t est l'occurrence d'un t  T dans les arguments de C}  V  { i, j | i  j, i, j  IN} tel que : a) pour chaque occurrence t d'un t  T dans C : f (t ) := i, i + 1 pour quelque i, 0  i < n tel que t = t, b) pour chaque v  V : f (v) = j, k pour quelques 0  j  k  n, et c) si pour un argument x . . . x d'un prédicat dans C, f (x ) = i , j , . . . , f (x ) = i , j , alors j = i pour 1  m < k. Par définition, nous disons alors que f (x . . . x ) = i , j .  La relation de dérivation pour RCG est définie comme suit :   Définition 6. Pour chaque clause  C : s'il existe une instantiation de cette clause par rapport à un w  T , on peut alors, dans un pas de dérivation ( . . .  . . .), remplacer la partie gauche de cette instantiation par sa partie droite.  est la clôture reflexive et transitive de . Le langage des chaînes d'une RCG G est L(G) = {w | S( 0, |w| )   par rapport à w}.  Comme exemple, prenons  G = {S, A, B}, {a, b}, {X, Y, Z}, S, P avec S(X Y Z)  A(X, Z) B(Y ), A(a X, a Y )  A(X, Y ), B(b X)  B(X), A(, )  , B()  . L(G) = {a b a | k, n  IN}.  La dérivation pour  w = aabaa est la suivante. La clause S est instantiée comme suit : S( 0, 5 )  A( 0, 2 , 3, 5 )B( 2, 3 ) S(X Y Z)  A(X, Z) B(Y )  0, 2  2, 3 3, 5 0, 2 3, 5 2, 3 aa b aa aa aa b Après cela, A( 0, 2 , 3, 5 )  A( 1, 2 , 4, 5 )  A( 2, 2 , 5, 5 )   :  A(aXaY ) A(X,Y )  et A(aXaY ) A(X,Y ) et A(, )    0, 1 1, 2 3, 4 4, 5 1, 2 4, 5  1, 2 2, 2 4, 5 5, 5 2, 2 5, 5 a a a a a a a  a     Pour le second prédicat, nous avons  B( 2, 3 )  B( 3, 3 )   : B(b X)  B(X)  2, 3  3, 3 3, 3 b   et B()    Définition 7. Une RCG est dite non-combinatoire si chaque argument d'un prédicat d'une  partie droite de clause consiste en une seule variable. Elle est linéaire si aucune variable n'ap- parait plus d'une fois dans la partie gauche d'une clause ou plus d'une fois dans la partie droite d'une clause. Elle est non-effaçante si pour chaque clause, chaque variable dans la par- tie gauche se trouve également dans la partie droite, et vice versa. Une RCG est simple si elle est non-combinatoire, linéaire et non-effaçante. Les RCGs simples sont équivalentes aux systèmes de réécriture hors contextes linéaires (LCFRS, (Weir, 1988)), c.f. (Boullier, 1998). Par conséquent, les RCGs simples sont légèrement sensibles au contexte (Joshi, 1985). L'idée générale de la transformation d'une TAG en RCG (positive simple) proposée par (Boullier, 1999b; Boullier, 1999a) est la suivante : la RCG contient des prédicats de deux types,  (X) et  (L, R), utilisés respectivement pour encoder les arbres initiaux et auxiliaires. X couvre la chaîne de l'arbre  en incluant tous les arbres ajoutés à , tandis que L et R couvrent les parties de la chaîne de  (incluant tous les arbres ajoutés) qui se trouvent à gauche et à droite du noeud pied. Les clauses de la RCG réduisent les arguments de ces prédicats en identifiant la partie provenant de l'arbre / lui-même et les parties provenant des arbres ajoutés par substitution ou adjonction. Un exemple est donné Fig. 2.  TAG :   S  a  S F     F  d   F  e   S  b  S c  RCG équivalente : S  (X)   (X) |  (X) |  (X)  (aF )   (F ) |  (F )  (aB B F )   (B , B )  (F ) |  (B , B )  (F )  (B b, cB )   (B , B )  (d)    (e)    (b, c)    Pour représenter un ensemble de phenomènes linguistiques, une extension des grammaires  d'arbres adjoints a été proposée, à savoir les TAGs à composantes multiples (MCTAG, (Weir, 1988)). Leur motivation réside dans le besoin de répartir la contribution d'un seul élément lexical (par exemple un verbe et ses arguments) sur plusieurs arbres élémentaires. Une MCTAG est donc composée d'ensembles d'arbres élémentaires. Si l'un de ces ensembles est utilisé lors d'une dérivation, chacun de ses éléments doit être utilisé.  Définition 8. Une MCTAG est un tuple  G = I, A, N, T, A tel que G := I, A, N, T est une TAG, et A est une partition de I  A.  Le type de MCTAG auquel nous sommes intéressé est Tree-Tuple MCTAG with Shared Nodes  (TT-MCTAG, (Lichte, 2007)). Les TT-MCTAGs ont été introduites afin d'analyser des phénomènes d'ordre de mots libre dans des langues comme l'allemand. Un exemple est (1) où l'argument es de reparieren précède l'argument der Mechaniker de verspricht et n'avoisine donc pas le prédicat dont il dépend. (1) ... dass es der Mechaniker zu reparieren verspricht ... que le le mécanicien réparer promet '... que le mécanicien promet de le réparer' Dans une TT-MCTAG, les ensembles élémentaires contiennent (1) un arbre lexicalisé , l'unique arbre tête, et (2) plusieurs arbres auxiliaires, les arbres arguments. Une liste composée d'une  tête et d'arguments s'appelle un tuple d'arbres. Lors de la dérivation, les arguments doivent soit  s'adjoindre directement à leur tête, soit être liés par une chaîne d'adjonctions à des racines, à un arbre adjoint à leur tête. Autrement dit, dans l'arbre de dérivation TAG correpondant, la tête doit dominer ses arguments de telle manière que les adresses des noeuds sur le chemin, sauf la première, doivent être  (i.e. le noeud racine). Cela traduit la notion d'adjonction avec partage de noeuds de (Kallmeyer, 2005).  Définition 9. 1. Une MCTAG  G = I, A, N, T, A est une TT-MCTAG ssi chaque   A a la forme {,  , . . . ,  } ou  (la tête) a au moins une feuille avec une étiquette termi- nale, et  , . . . ,  sont des arbres auxiliaires, les arguments. Nous écrivons un tel ensemble , { , . . . ,  } . 2. Un arbre de dérivation D dans I, A, N, T est admis comme arbre de dérivation TAG dans G ssi  (MC) ("multicomponent condition") Il existe  k ( k  1) instances  , . . . ,  de tuples élémen- taires, différentes les unes des autres, tel que  est l'ensemble d'étiquettes dans D.  (SN-TTL) ("tree-tuple locality with shared nodes") pour tous les noeuds  n , n , . . . , n ( m > 1) dans D avec l'étiquette du même tuple, tel que l'étiquette de n est la tête : pour chaque 1  i  m : ou bien n , n  P ou bien il existe des n , . . . , n étiquettes d'arbres auxiliaires telles que n = n , n , n  P et pour 1  j  k  1 : n , n  P avec  comme étiquette d'arc. Sur la Fig. 3, l'arbre auxiliaire NP est adjoint directement à verspricht (sa tête) tandis que l'arbre NP est adjoint à la racine d'un arbre qui est adjoint à la racine d'un arbre qui est adjoint à reparieren.  VP  VP verspricht , VP NP VP NP der Mech. , {}  VP  zu reparieren , VP NP VP NP es , {} arbre de dérivation : reparieren verspricht NP Mechaniker NP es F . 3 - Dérivation en TT-MCTAG pour (1)  Le problème de la reconnaissance pour TT-MCTAG est NP-difficile (Søgaard et al., 2007).  Nous introduisons ici une contrainte supplémentaire pour les TT-MCTAGs, fondée sur une idée de (Søgaard et al., 2007) : les TT-MCTAGs sont de rang k si, à chaque moment de la dérivation, le nombre d'arguments qui dépendent de têtes précédemment utilisées dans la dérivation et qui donc attendent leur adjonction, est limité à k.  Définition 10. Une TT-MCTAG  G = I, A, N, T, A est de rang k (appelée aussi k-TT-MCTAG) ssi pour chaque arbre de dérivation TAG D admis dans G : (TT- k) Il n'existe pas de noeuds n, h , . . . , h , a , . . . , a dans D tels que l'étiquette de a réfère à un argument de l'étiquette de h et h , n , n, a  P pour 0  i  k.  Nous construisons une RCG simple équivalente à une  k-TT-MCTAG de manière similaire à la conversion en RCG pour TAG. Nous considérons des prédicats  référant aux contributions des arbres élémentaires (et non des ensembles) utilisés dans une analyse. Rappelons que chaque TT-MCTAG est une TAG contrainte, ainsi une dérivation TT-MCTAG est une dérivation pour la TAG sous-jacente. En conséquence, nous pouvons construire une RCG pour la TAG sousjacente, tout en enrichissant les prédicats de façon à conserver l'information « doit être adjoint » pour les arbres arguments, information contraignant les clauses instantiables dans la dérivation RCG. Dans notre cas, la production d'un prédicat  contient non seulement la production de  et de ses arguments, mais également celle des arguments des prédicats précédemment instantiés dans la dérivation, et étant adjoints par la suite . Notre conversion mène à une RCG d'arité 2, et dont les noms de prédicats sont complexes. Afin de maintenir le nombre de noms de prédicats nécessaires finis, la limite k est cruciale. Un prédicat  doit encoder l'ensemble des arbres arguments dépendant d'arbres têtes précédemment consommés dans la dérivation. Cette ensemble est appelé liste des arguments en attente (List of Pending Arguments, LPA). Ces arbres doivent soit être adjoints à la racine de  ou être passé à la LPA des arbres adjoints. Afin de réduire le nombre de clauses, nous distingons, comme le propose (Boullier, 1999b), les clauses d'arbres (prédicats ... ), des clauses dites de « branchement » (prédicats adj . . . and sub . . . ). Nous avons ainsi trois types de prédicats :  1.  , LP A . Ces prédicats ont une arité 2 si  est un arbre auxiliare (contributions gauche et droite du noeud pied), une arité 1 s'il s'agit d'un arbre initial. Les clauses , LP A distribuent les variables référant aux productions des arbres substitués ou adjoints à  via une partie droite composée de prédicats adj et sub. La LP A est passée au prédicat adj du noeud racine, et les arguments de  distribués à l'ensemble des prédicats d'adjonction. 2. adj, , dot, LP A est un prédicat de branchement d'arité 2. Ici, la LP A contient a) la liste des arguments des têtes précédemment consommées si dot =  (i.e. noeud racine), et b) certains des arguments de  (toutes les distributions des arguments sur les noeuds d'adjonction ont été calculées, en tenant compte des contraintes d'étiquette du noeud dot). Les clauses adj, , dot, LP A adjoignent un arbre  sur le noeud dot de . Si  était dans la LP A, le prédicat d'arbre appelé reçoit LP A \ { }, dans le cas contraire,  est une tête, et la LP A reste inchangée. 3. sub, , dot est une clause de branchement d'arité 1, représentant les arbres pouvant être substitués au noeud dot de . Plus précisément, la conversion se passe comme suit : comme dans (Boullier, 1999b), nous définissons une chaîne de décoration  pour chaque arbre élémentaire . Les noeuds internes qui ne sont pas étiquetés NA recoivent deux variables L et R représentant les productions provenant d'une adjonction au noeud en question, les noeuds feuilles une variable X représentant la production provenant d'une substitution. Dans un parcours de type depth-first de , les variables sont collectées (les noeuds pieds apportant un caractère de séparation « , »), pour créer le(s) argument(s) du prédicat  .  1. Nous ajoutons un prédicat de départ  S et les clauses S(X)  ,  (X) pour l'ensemble des arbres initiaux .    VP  v  , {}  NP  n  , {}  NP  n  , {}    VP  v  VP ,       VP  NP  VP       VP  v  VP ,       VP  NP  VP       2. Pour chaque    I  A, soient L , R les symboles gauche et droite dans  pour le noeud d'adresse p, s'il s'agit d'un noeud d'adjonction, et X s'il s'agit d'un noeud de substitution. Soient p , . . . , p les noeuds d'adjonction potentiels, p , . . . , p les noeuds de substitution dans . La RCG produite contient alors toutes les clauses : , LP A ( )  adj, , p , LP A (L , R ) . . . adj, , p , LP A (L , R ) sub, , p (X ) . . . sub, , p (X ) telles que : - si LP A = , alors   {p , . . . , p } et LP A  LP A , - LP A = LP A  () où () est soit l'ensemble des arguments de  (si  est un arbre tête), soit  si  est lui-même un argument. 3. Pour tous les prédicats adj, , dot, LP A , la RCG contient les clauses adj, , dot, LP A (L, R)   , LP A (L, R) telles que  peut être adjoint au noeud dot de  et : - soit   LP A et LP A = LP A \ { }, - soit  /  LP A,  est un arbre tête, et LP A = LP A. 4. Pour tous les prédicats adj, , dot,  où le noeud dot de  n'est pas un noeud étiqueté OA, la RCG contient une clause adj, , dot,  (, )  . 5. Pour tous les prédicats sub, , dot et tous les  qui peuvent être substitués au noeud dot de , la RCG contient la clause sub, , dot (X)   ,  (X).  Prenons la TT-MCTAG de la Fig. 4. Pour celle-là, on obtient (entre autres) les clauses RCG   -   ,  (L v R)  adj,  , ,  (L, R) (une seule adjonction sur la racine d'adresse ) - adj,  , ,  (L, R)   ,  (L, R) |  ,  (L, R) (  ou  peuvent être adjoints à  dans  , LPA (ici vide) est transmise) -  ,  (L v , R)  adj,  , , { } (L, R) (dans  , il y a un unique noeud d'adjonction d'adresse  ; l'argument est passé à la nouvelle LPA) - adj,  , , { } (L, R)   ,  (L, R) |  , { } (L, R) |  , { } (L, R) (soit  est adjoit et retiré de la LPA ou bien un autre arbre (  ou  ) est adjoint) -  , { } (L v , R)  adj,  , , { ,  } (L, R) (ici encore, il y a un seul noeud d'adjonction dans  ; l'argument  est ajouté à la LPA) -  ,  (L X, R)  adj,  , ,  (L, R) sub,  , 1, (X) (adjonction à la racine et substitution au noeud 1 dans  ) - adj,  , ,  (, )   (l'adjonction à la racine de  n'est pas obligatoire tant que la LPA est vide) - sub,  , 1, (X)   ,  (X) (substitution de  au noeud d'adresse 1) -  ,  (n )   (aucune adjonction ou substitution dans  )  La dérivation RCG pour la chaîne d'entrée  n n n v v v v procède comme suit :  S(n  n n v v v v )   ,  (n n n v v v v )   adj,   , ,  (n n n v v v , )   ,  (n n n v v v , )  adj,  , , { } (n n n v v , )   , { } (n n n v v , )  adj,  , , { ,  } (n n n v , )   , { ,  } (n n n v , )  adj,  , , { ,  ,  } (n n n , )   , { ,  } (n n n , )  adj,  , , { ,  } (n n , ) sub,  , 1, (n )  adj,  , , { ,  } (n n , )  ,  (n )  adj,  , , { ,  } (n n , )    , { } (n n , )  adj,  , , { } (n , ) sub,  , 1, (n )  adj,  , , { } (n , )  ,  (n )  adj,  , , { } (n , )    ,  (n , )  adj,  , ,  (, )  ,  (n )   Cette exemple nécessite une LPA de capacité maximale 3, i.e. une 3-TT-MCTAG. Notons qu'avec cette construction, le groupement des arbres en tuples est perdu. Ainsi, dans notre exemple, nous ne savons plus quel arbre n provient de quel ensemble. Cependant, en pratique, nous créons une RCG pour une sous-grammaire TT-MCTAG sélectionnée à partir de la chaîne d'entrée. Si plusieurs occurrences d'un tuple donné sont sélectionnées, celles-ci se voient affectées un identifiant unique.  Avec cette construction, on peut démontrer le théorème suivant (voir (Kallmeyer & Parmentier,  2008)). Comme corollaire, les k-TT-MCTAGs sont légèrement sensibles au contexte.  Théorème 1. Pour chaque  k-TT-MCTAG G, il existe une RCG G simple telle que L(G) = L(G ) . Cet article a mis en relation deux formalismes grammaticaux, à savoir les grammaires TTMCTAG et grammaires RCG. TT-MCTAG est un formalisme de réécriture d'arbres qui permet de modéliser des phénomènes d'ordre des mots libre (existant par exemple en allemand). Les RCG, quant à elles, sont connues pour leur propriétés formelles avantageuses : les RCG sont analysables en un temps polynomial, et les RCG simples sont légèrement sensibles au contexte. De plus, des algorithmes d'analyse pour RCGs simples sont connus.  Nous avons montré comment convertir une TT-MCTAG restreinte (appelée  k-TT-MCTAG) en une RCG simple équivalente. Le résultat formel de cette conversion est que la classe des langages de chaînes générés par une k-TT-MCTAG est contenue dans la classe des langages générés par les RCGs simples. En particulier, k-TT-MCTAG est légèrement sensible au contexte.  Le résultat pratique de cette conversion réside dans l'implantation d'un analyseur syntaxique  pour TT-MCTAG utilisant un analyseur RCG comme noyau. Plus précisément, la TT-MCTAG est d'abord convertie en une RCG équivalente, utilisée alors pour l'analyse. Le résultat de l'analyse RCG est alors converti en analyse TT-MCTAG par interprétation des noms de prédicats des clauses instanciées. L'analyseur en question est utilisé pour développer une grammaire TTMCTAG de l'allemand, et est disponible librement sous licence GPL .  
