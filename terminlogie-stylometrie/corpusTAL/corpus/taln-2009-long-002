Une grammaire d'interaction (GI) (Guillaume & Perrier, 2008) permet de décrire la syntaxe  d'une langue en insistant sur la valence, c'est-à-dire la capacité des mots à se combiner. Cette valence s'exprime au moyen de polarités qui décorent les syntagmes ou les traits associés à ces syntagmes. D'autres formalismes utilisent cette notion, comme les grammaires catégorielles (Lambek, 1958), les grammaires d'unification polarisées (Kahane, 2004) ou encore les grammaires minimalistes (Chomsky, 1995). Une autre caractéristique des GI est l'utilisation de structures dites sous-spécifiées. Les grammaires de (Duchier & Thater, 1999) utilisent aussi ces structures mais avec un système de polarités moins riche.  Dans cet article, nous présentons un algorithme proche de celui décrit par (Earley, 1970) pour  l'analyse des grammaires hors-contexte. D'autres méthodes d'analyse existent pour les GI, comme par exemple la méthode shift-reduce de (Bonfante et al., 2003) qui réduit l'analyse à la réécriture de graphes. Ici, nous considérons une approche radicalement différente. Nous introduisons notre algorithme en utilisant une méthode standard de ce domaine : l'analyse déductive (Shieber et al., 1995). Cette approche évite d'inventer des notions et des notations ad hoc. Elle permet aussi aux lecteurs qui y sont habitués de comprendre rapidement les spécificités de l'analyse des GI. (Le Roux, 2007) décrit un algorithme très proche mais notre présentation, en décomposant la prédiction, est bien plus simple. Le reste de l'article s'organise comme suit : nous présentons les GI (section 2), puis nous décrivons l'algorithme (section 3). Nous discutons ensuite certains aspects techniques de l'algorithme (section 4) avant de conclure (section 5).  Nous reprenons la définition des GI donnée par (Guillaume & Perrier, 2008)  . Cependant, nous présentons ici une version sans structure de traits de manière à simplifier l'exposé.  La structure fondamentale des GI est la description d'arbre polarisée (DAP) qui représente un  fragment d'arbre d'analyse. Elle contient des noeuds polarisés, c'est-à-dire décorés de polarités.  Les GI distinguent 4 polarités P  = {, , =, }, respectivement positive, négative, neutre et virtuelle. Un multi-ensemble de polarités est saturé s'il contient exactement une polarité positive et exactement une polarité négative, ou bien s'il ne contient aucune polarité positive ni négative et au moins une polarité neutre. Un multi-ensemble de polarités est superposable s'il contient au plus une polarité positive et au plus une polarité négative.  Les noeuds polarisés sont étiquetés par une catégorie et une polarité. Un ensemble de noeuds est  saturé (resp. superposable) si tous ses éléments ont la même catégorie et si le multi-ensemble induit par leur polarité est saturé (resp. superposable).  Une DAP est un graphe. Il existe quatre relations binaires définies sur les noeuds polarisés d'une  DAP : la parenté immédiate >, la parenté lâche > , la précédence immédiate  et la précédence lâche  . De plus, pour être valide une DAP doit vérifier : - > et > définissent une structure d'arbre, -  et  ne sont définies que pour des noeuds ayant le même antécédent par >. Dans chaque DAP il existe des noeuds feuilles (sans descendant par > ou > ), appelés ancres. Pour alléger l'exposé , si n > m, on appelle m un noeud contraint (par n) et pour un ensemble N de noeuds, on définit N = {N|M  N , M > N} et N = {N|M  N , M > N }.  Une GI est un tuple  G = {, C, S, P, phon}, où  est l'alphabet des symboles terminaux, C est l'alphabet des symboles non-terminaux (ou catégories), S  C est le symbole initial, P est un ensemble de DAP dont les noeuds sont étiquetés par des éléments de C × P et phon est une fonction partielle des noeuds de P vers . Elle n'est définie que pour les ancres.  Le résultat d'une analyse syntaxique est un arbre syntaxique, c'est-à-dire un arbre totalement  ordonné dans lequel tous les noeuds sont étiquetés par une catégorie. On note lab (A) l'étiquette du noeud A. Certains noeuds feuilles F sont étiquetés par un terminal t. Dans ce cas, on notera mot (F ) = t, et mot(F ) =  sinon.  On notera M   N si le noeud M est le père du noeud N et N  [N , . . . , N ] si le noeud N est le père des noeuds de la liste ordonnée [N , . . . , N ]. L'ordre entre noeuds fils s'exprime à l'aide  de de la relation  . M  N indique que N est le successeur immédiat de M. On notera  la clôture transitive de  et  la clôture réflexive transitive de .  Enfin nous avons besoin de la projection phonologique P P d'un noeud, définie récursivement :   P P  (M) = [t] si M  [] et mot(M) = t [P P (N ) . . . P P (N )] si M  [N , . . . , N ]  Un arbre syntaxique T est un modèle du multi-ensemble de DAP  D s'il existe une fonction totale I des noeuds de D (notés N D) vers les noeuds de T (notés N T ) qui vérifie :  1. si A   N T alors I (A) est saturé et non-vide.  2. si M, N   N D et M > N alors I(M)  I(N)  3. si M, N   N D et M > N alors I (M)  I (N)  4. si M, N   N D et M  N alors I(M)  I(N)  5. si M, N   N D et M  N alors I (M)  I (N)  6. si A, B   N T et A  B alors il existe M  I (A) et N  I (B) tels que M > N  7. si A   N T alors lab(A) = lab(M) pour tout M  I (A)  8. si M   N D et phon(M) = m alors P P (I(M)) = [m]  Étant donné une GI  G = {, C, S, P, phon} et une phrase p = m , . . . , m de  , un arbre syntaxique T est un arbre d'analyse pour p s'il existe un multi-ensemble D de DAP issues de P tel que T est un modèle de D, la racine R de T est étiquetée par S et P P (R) = [m , . . . , m ]. Le langage engendré par G est l'ensemble des phrases de  pour lesquelles il existe un arbre d'analyse. Nous utilisons le cadre de l'analyse déductive (Shieber et al., 1995) pour expliquer notre algorithme : un état de l'analyse est décrit par un item et des règles de déduction permettent d'obtenir de nouveaux items à partir d'items déjà créés. On applique ces règles jusqu'à stabilisation de l'ensemble d'items. L'analyse est amorcée par la création d'un item axiome. La phrase d'entrée appartient au langage si un item spécifique, appelé item but est créé durant l'analyse .  Nos items sont de la forme  [A(H, N, F )    , i, j, (O, U, D)]. Ils sont constitués d'une règle pointée, de deux indices de position 0  i  j  n, où n est la longueur de la phrase d'entrée, et d'un triplet d'ensembles de noeuds qui contrôle l'utilisation des noeuds contraints.  La règle pointée A  (H, N, F )     affirme qu'il existe un noeud A de l'arbre d'analyse, modèle de l'ensemble H  N  F . Les éléments A dans  sont également des noeuds de l'arbre syntaxique. Ils indiquent que des sous-analyses ont déjà été effectuées et que l'on a trouvé pour  ces noeuds des ensembles d'antécédents saturés. Les éléments B  (H )de  signifient qu'il existe un noeud B dans l'arbre syntaxique dont un sous-ensemble des antécédents est H . De plus H est constitué uniquement de noeuds dans (H  N  F ) . Cet item prédit que l'arbre syntaxique contient A  [A . . . A B . . . B ] et que P P (A )  · · ·  P P (A ) = [m . . . m ].  C'est le contrôle de l'utilisation des noeuds contraints qui complique la tâche de l'analyseur. Le  triplet d'ensembles de noeuds (O, U, D) permet de vérifier les contraintes sur ces noeuds : - Les ensemble O et D contiennent des noeuds contraints qui seront disponibles quand on cherchera des antécédents pour prédire l'existence d'un nouveau noeud dans l'arbre syntaxique. - Les noeuds de O seront utilisés obligatoirement dans la sous-analyse courante. Pour qu'un item puisse compléter une analyse, il faudra impérativement que cet ensemble soit vide. - L'ensemble U contient des noeuds qui étaient disponibles puis ont été utilisés sans que l'on ait encore vérifié à quelle sous-analyse ils devaient appartenir.  Par ailleurs, on utilisera 3 symboles supplémentaires :  - , la partie gauche de la règle pointée axiome. On peut voir  comme une racine ajoutée à l'arbre syntaxique durant sa construction. - Le point  pourra devenir ou dans les règles de préparation à la prédiction (p et p ) pour indiquer que les items les contenant ne peuvent pas être utilisés dans d'autres règles. Nous aurons besoin de construire des suites d'ensembles de noeuds superposables qui respectent les relations de précédence des DAP. Étant donné un ensemble de noeuds N , nous définissons :  ord  (N ) = {[N . . . N ]| (N ) est une partition de N  1  i  k, N est superposable  si n , n  N et n  n alors 1  j < k t.q. n  N et n  N  si n , n  N et n  n alors 1  i < j  k t.q. n  N et n  N }  Dans cette section, on suppose vouloir analyser une phrase d'entrée p  = m , . . . , m avec une GI G = {, C, S, P, phon}.  Axiome  C'est la règle de départ. On se prépare à prédire un noeud de catégorie initiale S. Aucun mot n'a été lu et il n'y a aucune contrainte sur les relations lâches.  [  S(), 0, 0, (, , )]  ax  Prédiction  C'est la règle qui permet de commencer une sous-analyse. Nous l'avons divisée en 3 sous-règles pour introduire les différentes contraintes séparément.  [A(H, N, F )    C(H  ), i, j, (O, U, D)] [C(H , , )  , j, j, (, U, D  O)] p  Dans cette première étape, on va commencer une nouvelle sous-analyse à la limite de l'analyse  courante, en position j. On indique que le focus se situe sur un noeud C, pour lequel on a déjà choisi une partie des antécédents H . Les noeuds de O, qui sont les noeuds à utiliser obligatoirement dans la sous-analyse de A deviennent des noeuds disponibles pour l'analyse de C et toutes les sous-analyses suivantes.  [C(H  , , )  , j, j, (, U , D )] [C(H , N , )  , j, j, (, U , D )] p              H  N =  H  N est superposable N  D  P D = D  N U = U  (D  N )  Dans cette seconde sous-règle, les antécédents de C sont complétés avec l'ensemble de noeuds  N , choisis parmi les noeuds disponibles D et les racines des DAP de la GI dans P . Le triplet de vérification est ensuite mis à jour. Les noeuds contraints choisis pour compléter C ne sont plus disponibles et sont ajoutés à l'ensemble des noeuds utilisés.  [C(H  , N , )  , j, j, (, U, D)] [C(H , N , F )  , j, j, (O, U, D)] p              H  N  F est saturé   ord((H  N  F ) ) F = Q , Q  (H  N ) , Q  Q O = (H  N  F )  F aucun noeud ancre dans H  N  F  Dans la dernière étape de la prédiction, on complète les antécédents de C avec des noeuds  contraints par des noeuds déjà antécédents de C. On peut aussi sélectionner des noeuds dans la clôture transitive de cette relation à condition que leur prédécesseurs aient été eux-mêmes sélectionnés. L'ensemble des antécédents doit alors être saturé. Il faut ensuite prédire la forme des prochaines sous-analyses. Pour cela, il faut grouper les fils des antécédents et respecter leur catégories et les relations de précédence qui existent entre eux. On choisit donc une partition de (H , N , F ) qui respecte ord. Enfin, les noeuds à utiliser obligatoirement dans les sousanalyses sont les noeuds contraints par les antécédents qui ne sont pas eux-mêmes antécédents.  Balayage  C'est la règle qui vérifie les prédictions déjà effectuées par la présence d'un terminal à la position courante de l'analyse. C'est un cas particulier de la règle précédente quand l'un des antécédents de C est une ancre.  [C(H  , N , )  , j, j, (, U, D)] [C(H , N , F )  , j, j + 1, (, U, D)] b                  H  N  F est saturé (H  N  F ) =  F = Q , Q  (H  N ) , Q  Q (H  N  F )  F =  un unique noeud ancre a dans H  N  F phon (a) = p  Si on lit sur la chaîne d'entrée le terminal attendu à la position courante, on fait progresser  l'analyse. Cette règle ne s'applique que si tous les noeuds contraints par les antécédents sont eux-mêmes antécédents, puisqu'il n'y a pas de sous-analyse dans laquelle utiliser ces noeuds.  F  1 - les DAP et l'arbre d'analyse pour Jean que Marie semble aimer dort.  Complétion  Cette règle permet de revenir d'une sous-analyse et d'étendre l'analyse courante.  [A(H, N, F )    C(H  ), i, j, (O , U , D )] [C(H , N , F )  , j, k, (, U , D )] [A(H, N, F )  C  , i, k, (O , U , D )] c                  N  D  O  P D  (D  O )  N U  U O = O  U D = D  U U = U  O  On doit ici s'assurer que la sous-analyse de C peut être branchée sur l'analyse courante :  - L'ensemble des noeuds disponibles dans la sous-analyse est un sous-ensemble des noeuds disponibles dans l'analyse principale. En d'autres termes, la sous-analyse a pu utiliser des noeuds qui étaient disponibles dans l'analyse principale mais n'a pas pu rendre de nouveaux noeuds disponibles sans les avoir utilisés. - Pour les mêmes raisons, l'ensemble des noeuds utilisés dans l'analyse principale doit être un sous-ensemble des noeuds utilisés dans la sous-analyse. - On retire des noeuds à utiliser obligatoirement ceux qui ont été utilisés dans la sous-analyse.  Item but  L'analyse réussit si l'on obtient [  S, 0, n, (, , )].  Pour voir comment les relations de parenté lâche sont contrôlées, nous allons analyser la phrase  Jean que Marie semble aimer dort. On peut voir les DAP utilisées pour l'analyse sur la Figure 1. Elles proviennent du logiciel L . Nous appellerons les descriptions j, q, m, s, a, d et p et nous désignerons les positions des noeuds par leur adresse de Gorn. Par exemple la racine de la DAP associée à Marie est m et le noeud le plus éloigné de la racine de la DAP associée à semble est s . Les relations > et > sont représentées par des traits, respectivement plein et pointillé. Les relations  et  sont représentées par des flèches, respectivement noire et colorée. Les items qui permettent d'arriver une analyse et les règles pour les produire sont listés dans la Table 1.  L'algorithme commence par prédire une racine S image de d et p (items 1, 2 et 3), puis ordonne  les fils de ces noeuds (item 4). L'analyse se poursuit par la prédiction d'un noeud N P dont un des antécédents doit être d , puisque d a été choisi plus tôt. L'analyse se poursuit jusqu'à la prédiction du noeud S (item 12) dont la projection phonologique est que Marie semble aimer. Ce noeud a pour antécédents q et s. Le noeud q contraint par q n'est pas antécédent, il doit donc être obligatoirement utilisé dans cette sous-analyse et il est ajouté à l'ensemble O de cet item. Ce noeud devient ensuite disponible pour l'analyse de que et semble mais n'est pas utilisé. Il est donc toujours dans l'ensemble O de l'item 22, ainsi que dans celui de l'item 24.  Les items 25, 26 et 27 décrivent la prédiction du noeud S dont la projection phonologique est  aimer. On sélectionne q comme antécédent qui devient utilisé (ensemble U ). Lors de la complétion du S dont la projection phonologique est que Marie semble aimer (item 34), le contrat qui forçait l'utilisation de q a été rempli et on retire donc ce noeud des noeuds obligatoires. Le reste de l'analyse ne pose pas de problème particulier.  L'algorithme présenté maintient un invariant tout au long de l'analyse. Chaque item de la forme  [A(H, N, F )    , i, j, (O, U, D)] assure que : - A est modèle d'un ensemble saturé de noeuds qui ne sont plus disponibles pour être antécédents d'un autre noeud de l'arbre syntaxique en construction. Il en est de même des noeuds dans . Les conditions 1, 7 et 3 (cas réflexif) que doit vérifier un modèle sont respectées. - Les ensembles  sont superposables. On a   (A ) (conditions 2 et 6) - l'ordre des  est compatible avec les relations d'ordre des DAP (conditions 4 et 5). - P P ( )  . . .  P P ( ) = [m · · · m ] - les noeuds de O sont des noeuds contraints en relation avec des noeuds de DAP qui sont antécédents de A et qui n'ont pas encore été utilisés comme antécédents. - les noeuds de D sont des noeuds contraints en relation avec des noeuds de DAP qui sont antécédents de noeuds de l'arbre syntaxique situés entre sa racine et A et qui n'ont pas encore été utilisés comme antécédents - un noeud N de U est un noeud contraint en relation par > avec un noeud de DAP qui est antécédent d'un noeud situé à la fois entre la racine de l'arbre syntaxique et A, distinct de A et entre la racine et I (N) (condition 3). On peut vérifier cet invariant par induction sur les règles. En d'autres termes un tel item affirme qu'il existe une fonction partielle J des noeuds d'un sous-ensemble des DAP d'une GI vers un arbre syntaxique de racine étiquetée par O et qui a pour projection phonologique m . . . m . Cette fonction J est similaire à la fonction I des modèles. Elle vérifie les mêmes propriétés mais les conditions 2-5 ne sont respectées que si les deux noeuds sont dans le domaine. L'algorithme étend cette fonction J jusqu'à (1) l'obtention d'une fonction totale et (2) la couverture complète de la chaîne d'entrée. J définit alors un arbre syntaxique qui est un arbre d'analyse.  D'autre part, s'il existe un arbre syntaxique pour une GI et une phrase d'entrée, un parcours  préfixe de cet arbre permet de retrouver les items créés par l'algorithme  1 [  S(), 0, 0, (, , )]  ax 2 [S(, , )  , 0, 0, (, , )] p (1) 3 [S(, {d, p}, )  , 0, 0, (, , )] p (2) 4 [S(, {d, p}, )  NP(d )V (d )PUN(p ), 0, 0, (, , )] p (3) 5 [NP({d }, , )  , 0, 0, (, , )] p (4) 6 [NP({d }, {j, q}, )  , 0, 0, (, , )] p (5) 7 [NP({d }, {j, q}, )  NP(j , q )S(q ), 0, 0, (, , )] p (6) 8 [NP({j , q }, , )  , 0, 1, (, , )] b  p  p (7) 9 [NP({d }, {j, q}, )  NP  S(q ), 0, 1, (, , )] c (7, 8) 10 [S({q }, , )  , 1, 1, (, , )] p (9) 11 [S({q }, {s}, )  , 1, 1, (, , )] p (10) 12 [S({q }, {s}, )  CPL(q )NP(s )V (s )S(s ), 1, 1, ({q }, , )] p (11) 13 [CPL({q }, , )  , 1, 1, (, , {q })] p (12) 14 [CPL({q }, , )  , 1, 1, (, , {q })] p (13) 15 [CPL({q }, , )  , 1, 2, (, , {q })] b (14) 16 [S({q }, {s}, )  CPL  NP(s )V (s )S(s ), 1, 2, ({q }, , )] c (12, 15) 17 [NP({s }, , )  , 2, 2, (, , {q })] p (16) 18 [NP({s }, {m}, )  , 2, 2, (, , {q })] p (17) 19 [NP({s }, {m}, )  NP(m ), 2, 2, (, , {q })] p (18) 20 [NP({m }, , )  , 2, 3, (, , {q })] b  p  p (19) 21 [NP({s }, {m}, )  NP, 2, 3, (, , {q })] c (19, 20) 22 [S({q }, {s}, )  CPL NP  V (s )S(s ), 1, 3, ({q }, , )] c (16, 21) 23 [V ({s }, , )  , 3, 4, (, , {q })] b  p  p (22) 24 [S({q }, {s}, )  CPL NP V  S(s ), 1, 4, ({q }, , )] c (22, 23) 25 [S({s }, , )  , 4, 4, (, , {q })] p (24) 26 [S({s }, {a, q }, )  , 4, 4, (, {q }, )] p (25) 27 [S({s }, {a, q }, )  NP(a , s )V (a , q )NP(q , a ), 4, 4, (, {q }, )] p (26) 28 [NP({a , s }, , )  , 4, 4, (, {q }, )] p  p  p (27) 29 [S({s }, {a, q }, )  NP  V (a , q )NP(q , a ), 4, 4, (, {q }, )] c (27, 28) 30 [V ({a , q }, , )  , 4, 5, (, {q }, )] b  p  p (29) 31 [S({s }, {a, q }, )  NP V  NP(q , a ), 4, 5, (, {q }, )] c (29, 30) 32 [NP({q , a }, , )  , 5, 5, (, {q }, )] p 3  p  p (31) 33 [S({s }, {a, q }, )  NP V NP, 4, 5, (, {q }, )] c (31, 32) 34 [S({q }, {s}, )  CPL NP V S, 1, 5, (, , )] c (24, 33) 35 [NP({d }, {j, q}, )  NP S, 0, 5, (, , )] c (9, 34) 36 [S(, {d, p}, )  NP  V (d )PUN(p ), 0, 5, (, , )] c (4, 35) 37 [V ({d }, , )  , 5, 6, (, , )] b  p  p (36) 38 [S(, {d, p}, )  NP V  PUN(p ), 0, 6, (, , )] c (36, 37) 39 [PUN({p }, , )  , 6, 7, (, , )] b  p  p (38) 40 [S(, {d, p}, )  NP V PUN, 0, 7, (, , )] c (38, 39) 41 [  S, 0, 7, (, , )] c (1, 40)  T  1 - Items pour l'analyse de Jean que Marie semble aimer dort.  Le problème de l'analyse des GI est un problème NP-difficile dans le cas lexicalisé et même en  l'absence d'ambiguïté lexicale (Bonfante et al., 2003).  En regardant les règles de notre algorithme, on peut voir plusieurs sources d'indéterminisme :  - dans la règle p , il faut choisir de nouveaux antécédents (l'ensemble N ) qui soient superposables avec les antécédents hérités des choix précédents (l'ensemble H ). Ces nouveaux antécédents sont à choisir parmi les noeuds disponibles et les racines des DAP de la GI utilisée. Il y a un nombre exponentiel de tels choix, d'autant plus grand que les GI réalistes contiennent plus de 2000 DAP. Cependant, en pratique, on va filtrer les choix possibles grâce aux catégories et aux polarités. De plus, les GI utilisées dans l'implantation L sont lexicalisées. On ne va donc considérer qu'un sous-ensemble des DAP de la grammaire, qui correspond aux DAP qui ont pour ancre un mot de la phrase d'entrée. Enfin, des techniques de filtrages lexical (supertagging) très efficaces ont été développées pour les GI, comme (Bonfante et al., 2006) qui permettent de restreindre de façon drastique le nombre de DAP qui peuvent être utilisées. - dans la règle p et la règle b, il faut choisir un sous-ensemble de noeuds contraints par des antécédents déjà choisis. Ici encore il existe un nombre exponentiel de choix. Cependant, dans les GI utilisées en pratique, les noeuds des DAP ont au plus un successeur par la relation > et il n'existe pas de chaîne de noeuds reliés par > . On peut donc borner le nombre de noeuds dans F par le nombre de noeuds dans H  N . - dans la règle p , on doit ordonner et partitionner les fils par > des antécédents. Dans le cas où il n'existe aucune relation de précédence entre ces fils, il y a à nouveau un nombre exponentiel de possibilité. Cependant, en pratique, le nombre de noeuds à ordonner/partitionner est petit. On peut imaginer calculer l'ordre de façon paresseuse en l'étendant à chaque complétion, comme le proposent (Nederhof et al., 2003) pour les pomset-CFG. On remarque que la règle qui fait intervenir le plus d'indices de position est la complétion et qu'il n'y a pas d'indéterminisme à cette étape. Ce n'est donc pas directement la taille de la phrase qui rend le problème de l'analyse des GI difficile mais la taille de la GI et des DAP à considérer. La longueur de la phrase ne joue qu'un rôle indirect, le nombre de DAP utilisables augmentant avec le nombre de mots.  Nous avons présenté un algorithme d'analyse pour les GI. Bien que nous ayons utilisé une  version sans structure de traits, nous pensons qu'il n'y a aucune difficulté majeure à y ajouter un mécanisme d'unification.  L'originalité de notre travail réside dans l'utilisation du cadre formel de l'analyse déductive pour  un formalisme qui se réclame de l'approche par théorie des modèles (Pullum & Scholz, 2001). Ce cadre formel permet de distinguer les sources de l'indéterminisme qui rendent difficile le problème de l'analyse dans les GI. Ce travail est donc un premier pas vers une étude plus approfondie de sa complexité.  À l'avenir, il sera intéressant de rechercher, comme pour la méthode shift-reduce ou comme  pour les (k-)TT-MCTAG (Kallmeyer & Parmentier, 2008), des approximations de l'algorithme ou du formalisme qui ne considèrent qu'un nombre borné de noeuds à chaque étape, de manière  à rendre l'analyse efficace (polynomiale).   
