Nous poursuivons ici un travail commencé depuis plus de dix ans autour de la construction semiautomatique de grammaires computationnelles. Dans le cadre du formalisme des Grammaires d'Interaction (GI)(Guillaume et Perrier, 2009), nous avons développé FRIGRAM , une grammaire du français, et LEOPAR , un analyseur syntaxique pour les GI, permet d'appliquer cette grammaire à l'analyse de textes en français.  Notre ambition est d'obtenir une grammaire à large couverture pour analyser des corpus tout  venant. Même si nous sommes ouverts à intégrer des méthodes probabilistes dans notre approche, nous souhaitons conserver une base symbolique pour être en mesure de produire des analyses suffisamment riches pour que l'on puisse calculer à partir d'elles des représentations sémantiques complètes.  Nous devons faire face à un premier défi, celui de maintenir la cohérence d'une grammaire  qui est nécessairement de taille importante. Certes, l'organisation d'une telle grammaire sous forme d'une hiérarchie de modules à l'aide d'une relation d'héritage facilite la tâche, mais cela ne résoud pas tout. Par ailleurs dans l'analyse syntaxique, nous sommes confrontés à un second défi, celui de l'explosion du nombre de structures syntaxiques candidates pour l'analyse d'une phrase.  Pour répondre à ces deux défis, nous pensons qu'il est utile d'analyser la grammaire de façon  systématique pour prévoir les interactions entre les structures élémentaires qui la définissent. Un travail a commencé à être mené sur FRIGRAM mais il peut s'étendre aux grammaires construites dans d'autres formalismes, pour peu que ces grammaires soient lexicalisées.  Lorsque l'on analyse une phrase avec une grammaire lexicalisée, la première étape consiste à  assigner à chaque mot de la phrase une structure syntaxique élémentaire de la grammaire. On obtient ce qu'on appelle une sélection lexicale. Le nombre de sélections lexicales possibles est exponentiel par rapport à la longueur de la phrase.  Pour filtrer les sélections lexicales, (Bonfante et al., 2009) ont introduit la notion de compagnon.  Un compagnon d'une structure syntaxique élémentaire est une structure syntaxique élémentaire qui peut se combiner avec la première dans la composition syntaxique d'une phrase. Le principe de filtrage est ensuite le suivant : si dans une sélection lexicale, il existe une structure syntaxique élémentaire qui ne trouve ni compagnon à gauche ni compagnon à droite, la sélection peut être éliminée. L'application de ce principe permet de réduire drastiquement le nombre de sélections lexicales. Les compagnons de chaque structure syntaxique élémentaire peuvent être pré-calculés sur la grammaire et pour réduire le nombre de calculs, ceux-ci sont effectués sur les structures syntaxiques élémentaires avant ancrage par des mots particuliers.  La faiblesse du principe de filtrage fondé sur les compagnons est qu'il est totalement indifférent  aux contraintes de localité. Ainsi, si un mot du début d'une longue phrase trouve le compagnon de la structure syntaxique qu'il ancre auprès d'un mot qui est en fin de phrase, quelle que soit la longueur de la phrase, le principe est respecté.  C'est pour pallier cet inconvénient que nous proposons d'aller plus loin dans l'analyse statique des  interactions entre structures syntaxiques élémentaires de la grammaire. Considérant un couple particulier de compagnons, nous proposons un algorithme qui permet de prévoir uniquement d'après la grammaire les structures syntaxiques élémentaires qui peuvent s'intercaler entre ces compagnons dans la composition syntaxique d'une phrase. Ce calcul devrait nous permettre d'aller plus loin dans le filtrage des sélections lexicales par application du principe suivant : si dans une sélection lexicale, nous sommes sûrs que deux mots ont leurs structures syntaxiques qui sont compagnons, nous devons vérifier que tous les structures syntaxiques ancrant les mots intermédiaires sont dans l'ensemble pré-calculé selon notre algorithme. Dans la section 2, nous préciserons le concept de compagnon. Dans la section 3, nous décrirons l'algorithme de calcul des structures syntaxiques élémentaires s'intercalant entre deux compagnons et dans la section 4, nous déroulerons l'algorithme sur un exemple.  Nous nous situons dans le cadre de formalismes grammaticaux où les objets manipulés sont des  structures syntaxiques notées SSynt. Parmi, celles-ci, nous distinguons les structures finales qui sont celles représentant la syntaxe complète des phrases. Une opération de composition binaire que nous noterons permet de combiner les SSynt . Les grammaires y sont définies comme des ensembles finis de SSynt, que nous appellerons structures syntaxiques élémentaires et que nous noterons SSyntE. Dans l'utilisation que nous faisons de la notion de compagnon, il est nécessaire que les grammaires soient lexicalisées : les SSyntE doivent être ancrées par des mots de la langue. Pour simplifier l'exposé, on considérera même que chaque SSyntE a une ancre unique.  F  1 - Une SSyntE ancrant femme compagnon à droite d'une SSyntE ancrant est  Dans ces conditions, on appelle compagnon à droite (compagnon à gauche) d'une SSyntE S  toute SSyntE S telle que (S , S ) soit définie et soit compatible avec le fait que l'ancre de S précède (suit) celle de S dans l'ordre linéaire de la phrase.  Appliquons cette notion au formalisme des GI où les SSynt sont des forêts d'arbres ordonnés  sous-spécifiés. Les noeuds représentent des syntagmes et leurs propriétés morpho-syntaxiques sont représentées par des traits qui présentent la particularité d'être polarisés. Le système de polarités permet d'exprimer l'état de saturation des SSynt et leur aptitude à interagir entre elles. Les structures finales sont des arbres saturés. L'opération de composition syntaxique entre deux SSynt S et S consiste à fusionner un noeud de S avec un noeud de S de façon à saturer un trait polarisé de S qui ne l'était pas initialement . Pour une description exhaustive du formalisme des GI, le lecteur peut se reporter à (Guillaume et Perrier, 2009). La grammaire à laquelle nous allons appliquer nos idées est la grammaire d'interaction du français FRIGRAM.  La figure 1 montre la SSyntE S  ancrant le verbe est quand il prend un syntagme nominal comme  F  2 - La SSynt résultant de la composition syntaxique de la SSyntE ancrant femme avec la SSyntE ancrant est  attribut du sujet et un de ses compagnons à droite, la SSyntE S  ancrant le nom femme quand il est tête d'un syntagme nominal . La figure 2 en fournit la justification en montrant (S , S ) obtenu en fusionnant le noeud nAttr de S avec le noeud nNp de S de façon à saturer les deux traits polarisés du premier. Le résultat de la fusion des deux noeuds est le noeud nAttr-nNp. L'ordre des noeuds dans l'arbre montre bien que le compagnon est à droite.  On peut calculer de façon systématique tous les compagnons à droite et à gauche des SSyntE  d'une grammaire mais pour éviter d'avoir un nombre trop important de calculs à faire, on le fait sur les SSyntE non ancrées. Ainsi par exemple si on considère la SSyntE non ancrée correspondant à S , on trouve dans FRIGRAM 129 compagnons permettant de saturer les traits du noeud nAttr : 58 à gauche seulement, 59 à droite seulement et 12 qui sont à la fois à gauche et à droite. Pour avoir l'ensemble des compagnons de S , il faut ajouter ceux qui permettent de saturer des traits polarisés de nSubj et de nPred.  Dans une phrase donnée, le nombre de compagnons possibles pour une SSyntE ancrant un mot  est réduit et on utilise cette information pour filtrer les sélections lexicales. (Bonfante et al., 2009) ont montré que le principe que toute SSyntE d'une sélection lexicale doit y trouver au moins un compagnon permet de filtrer efficacement les sélections lexicales. Ainsi pour la phrase &#34;Marie est considérée comme une femme intelligente.&#34;, la grammaire FRIGRAM offre 13 047 840 sélections lexicales possibles et le filtrage fondé sur les compagnons permet de réduire ce nombre à 354. Le but du travail présenté ici est de montrer qu'il est encore possible d'aller plus loin pour pallier une faiblesse du principe : il est indifférent à la distance entre une SSyntE et ses compagnons. Dans notre exemple, comme c'est indiqué plus haut, S doit aller jusqu'au mot une pour trouver son premier compagnon. L'idée de l'algorithme présenté à la section suivante est de prévoir à partir de la grammaire les SSyntE qui peuvent être situées dans une sélection lexicale entre une SSyntE donnée et ses compagnons, calcul qui servira de base à un nouveau principe de filtrage.  L'algorithme va être appliqué au formalisme des GI mais cette application peut être étendu à  tout formalisme manipulant des forêts d'arbres ordonnés avec des structures finales qui sont des arbres et une opération de composition qui est une forme de superposition d'arbres. Il part de l'observation que la plupart du temps, dans FRIGRAM, la composition d'une SSyntE avec un de ses compagnons produit une SSynt qui définit une zone triangulaire dont la base est délimitée par les deux ancres issues des SSyntE qui ont été composées et dont le sommet est le premier ancêtre commun. Désormais, nous appelleront une telle SSynt une structure bi-ancrée.  Formellement, une structure bi-ancrée S est une SSynt qui a deux ancres distinguées Ag et Ad,  la première, l'ancre gauche, se situant avant la seconde, l'ancre droite, dans l'ordre linéaire de la phrase. En plus, il existe dans S deux suites de noeuds R, N , . . . , Ag et R, M , . . . , Ad ayant un début commun, le noeud R, et telles que chaque noeud de la suite est fils de celui qui le précède. La figure 2 montre un exemple de structure bi-ancrée. Les deux suites de noeuds formant les côtés du triangle sont nPred, nInfl, nVanch et nPred, nAttr-nNp, nNmax, nN.  Ces deux suites permettent de définir une partition sur les noeuds de S entre ceux qui se situent à  l'intérieur du triangle défini par les deux chemins et ceux qui se situent à l'extérieur. Un noeud est interne s'il se situe après l'ancre gauche et avant l'ancre droite selon l'ordre défini sur la structure bi-ancrée . Un noeud qui n'est pas interne, est un noeud frontière s'il fait partie d'une des deux listes de noeuds distinguées, sinon il est externe.  Le principe de l'algorithme s'appuie sur la forme particulière d'une structure bi-ancrée qui a la  conséquence suivante : toute SSyntE dont l'ancre s'insère entre les deux ancres distinguées doit être reliée à un noeud interne ou frontière. Elle peut l'être de façon directe par composition avec la structure bi-ancrée mais elle peut l'être de façon indirecte via une chaîne d'autres SSyntE. Ces SSyntE doivent toutes avoir la propriété d'étendre vers le bas la structure bi-ancrée avec un nouveau noeud interne. C'est cela qui va être utilisé par l'algorithme qui se présente ainsi :  fonction  _ (S, Ag, Ad, noeuds) initialiser G au graphe vide tantque noeuds est non vide choisir un noeud N de noeuds et le retirer de cet ensemble M f = _ ( N, S) pourchaque SSyntE S de la grammaire si (M f , S ) (S , Ag , Ad , A , noeuds ) = (S , S , Ag, Ad, M f ) G = _ (S , Ag , Ad , noeuds ) si (A , S , Ag , Ad )) G = G  _ (G , S )) sinon G = G  G retourner G  La fonction  _ prend en entrée une structure bi-ancrée S avec ses deux ancres distinguées gauche et droite Ag et Ad ainsi qu'un ensemble noeuds de S qui vont être le point de départ de l'expansion vers le bas de S. Au départ, noeuds est initialisés aux noeuds internes et frontière de S à l'exception des ancres Ag et Ad.  En sortie, la fonction  _ retourne un graphe dont les noeuds sont étiquetés par des SSyntE de la grammaire. Il s'agit en fait d'une forêt d'arbres dont la sémantique est la suivante : Si une phrase est analysée avec succès par la grammaire à partir de la SSynt S et si w et w sont les deux mots de la phrase attachés aux ancres distinguées de S, pour tout mot w situé entre w et w qui contribue à l'analyse avec la SSyntE S qu'il ancre, il existe une occurrence de S dans le graphe dont tous ses prédécesseurs dans le graphe participe à l'analyse en ancrant des mots situés entre w et w .  Expliquons maintenant l'algorithme. Au départ on choisit un noeud N de l'ensemble noeuds que  l'on retire de l'ensemble. Ce noeud va servir de point de départ à l'expansion vers le bas de S. A l'aide de la fonction _ , on crée un motif M f qui va permettre de filtrer les SSyntE de la grammaire pertinentes pour cette expansion. M f est formé du noeud N ainsi que de tous ses ancêtres et tous ses frères dans S. On ajoute en plus un fils N de N qui est laissé complètement sous-spécifié quant aux traits dont il est porteur. Il est seulement ordonné par rapport à ses frères éventuels qui sont sur la frontière. Ce noeud est capital car c'est lui qui va permettre l'expansion .  Ensuite, on passe en revue toutes les SSyntE de la grammaire à l'aide du filtre M f . La fonction  booléenne teste si M f subsume une SSyntE S quelconque de la grammaire. Cela veut dire que tout noeud de M f s'interprète dans S et que cette interprétation conserve les relations père-fils ainsi que celles de précédence. En plus, les traits attachés à chaque noeud de M f doivent aussi s'interpréter par des traits attachés à son noeud image dans S en respectant un certain nombre de propriétés qui sont spécifiques au formalisme grammatical utilisé. Par exemple, pour les GI, la polarité du trait image doit être compatible avec celle du trait antécédent.  Ensuite, si le test est positif, à l'aide la fonction  , on compose la SSyntE S avec S en suivant le motif M f et en utilisant l'opération de composition syntaxique propre au formalisme. On obtient une SSyntE S et on distingue dans celle-ci les ancres gauche et droite Ag et Ad qui sont la transposition dans S des ancres Ag et Ad de S. En plus, on repère l'ancre A apportée par S car sa position va jouer un rôle décisif pour la suite. La variable noeuds représente l'ensemble des noeuds de S qui vont servir de point de départ aux expansions futures. Ce sont les noeuds internes de S qui n'étaient présents au départ dans noeuds.  L'étape suivante consiste à appliquer récursivement la fonction  _ . Elle va permettre de récupérer un graphe G et c'est là que l'ancre A va jouer un rôle important par le biais de la fonction booléenne . Cette fonction teste si l'ancre A est un noeud interne à la structure bi-ancrée S . Si nous reprenons notre exemple avec la phrase à analyser &#34;où Marie est-elle considérée comme une femme intelligente ?&#34;, les SSyntE associées aux mots où et une vérifient toutes les deux la condition exprimée par la fonction . Pour où, cela provient du fait que la SSyntE modélise une extraction. Pourtant, seule la seconde vérifie la condition exprimée par la fonction , le mot une se situant entre est et femme. Dans ce cas, il va falloir ajouter S au graphe G . On l'ajoute comme nouvelle racine en le reliant par un arc à toutes les anciennes racines de G . C'est le rôle de la fonction _ . Il ne reste plus qu'à faire l'union du graphe obtenu avec G, dans l'état où il est après utilisation d'un certain nombre de noeuds de noeuds. Si A est un noeud externe, on se contente de faire l'union de G avec G.  Appliquons l'algorithme à la structure bi-ancrée S de la figure 2. La valeur initiale de noeuds  est l'ensemble {nInfl, nPred, nAttr-nNp, nDet, nNmax}. On choisit ensuite un noeud N dans cet ensemble, par exemple nInfl. On crée le motif M f correspondant à l'aide de la fonction _ . C'est le sous arbre de la structure bi-ancrée formé des trois noeuds nPred, nInfl et nAttr-nNp. On y ajoute un nouveau fils N de nInfl.  F  3 - SSyntE ancrant les adverbes modificateurs de verbes situés après ces verbes  Ensuite, on essaie de faire coïncider le motif M f avec un sous-arbre de chaque SSyntE de  FRIGRAM. Prenons un cas où l'appariement réussit, celui de la SSyntE ancrant les adverbes modificateurs de verbes et situés après ces verbes, nommée ADV mod_V et représentée sur la figure 3. La condition (M f , ADV mod_V ) est vraie et on superpose alors ADV mod_V avec S en suivant le motif M f . Cela revient à étendre S en ajoutant comme frère droit de nVanch le noeud nAdvmax de ADV mod_V avec son fils nAdv.  On relance la fonction principale  _ sur cette nouvelle structure bi-ancrée S avec comme valeur pour noeuds le singleton {nAdvmax}. Nous passerons sur le détail de son exécution en en donnant seulement le graphe G qu'elle retourne. Ce graphe est formé de deux noeuds isolés ADV mod_ADV 1 et ADV mod_ADV 2 ancrant les adverbes modificateurs d'adverbes.  Comme l'ancre de ADV mod_V est un noeud interne, la condition  est vraie et on complète le graphe G qui est initialement vide à l'aide de la fonction _ . On obtient un graphe de trois noeuds avec comme racine ADV mod_V et ses deux successeurs immédiats ADV mod_ADV 1 et ADV mod_ADV 2.  L'algorithme se poursuit par la sélection d'autre noeud de l'ensemble noeuds, nPred par exemple.  Va s'ensuivre une extension de S vers le bas à partir de ce noeud. Il serait trop long de la décrire en détail mais il est important de noter que cette extension va entraîner la création d'un noeud qui représente un syntagme propositionnel. Ce syntagme peut représenter une proposition relative telle que &#34;qu'elle a&#34; dans la phrase &#34;Marie est avec l'expérience qu'elle a une femme intelligente.&#34;. Compte tenu de la récursivité de la langue liée aux propositions qui peuvent s'imbriquer les unes dans les autres à l'infini, l'exécution de l'algorithme entre ici dans une boucle infinie. Pour éviter la non terminaison de l'algorithme, il suffit de couper l'extension vers le bas de la structure bi-ancrée quand on produit des noeuds source de bouclage ou si l'on atteint une certaine taille .  En définitive, nous obtiendrons un graphe G acyclique qui n'est pas forcément complet. Il est  éventuellement amputé vers la &#34;fin&#34; mais ce qui est important c'est que toutes les racines peuvent être calculées. Dans notre exemple, le graphe aura quelques dizaines de racines qui sont des SSyntE ancrant des adverbes modificateurs de verbes ou de phrases, des adverbes entrant dans des constructions consécutives ou comparatives, des prépositions introduisant des compléments modificateurs de phrases, des pronoms comme tous ou chacun, des conjonctions de subordination introduisant des propositions circonstancielles, des déterminants et des adjectifs épithètes gauche.  Si S  a un comme compagnon unique S dans une sélection lexicale qui produit une analyse, selon la sémantique du graphe exposée plus haut (même si ce graphe est incomplet), pour toute SSyntE S s'intercalant entre les deux compagnons dans la sélection, il existe un chemin dans le graphe commençant à une racine et terminant à un noeud qui n'a pas de successeur ou est une occurrence de S .  Si le calcul des compagnons est implémenté, ce n'est pas le cas pour l'algorithme de détection  des SSyntE pouvant s'insérer entre deux compagnons. Seule son implémentation permettra de dire dans quelle mesure cet algorithme est utile pour accroître l'efficacité du filtrage.  
