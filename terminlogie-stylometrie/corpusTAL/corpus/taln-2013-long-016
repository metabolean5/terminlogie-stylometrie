L'étude de phénomènes d'ellipses dans les modèles de l'interface syntaxe-sémantique pose  certains problèmes du fait que le matériel linguistique effacé au niveau phonologique est néanmoins présent au niveau sémantique. Tel est le cas d'une ellipse verbale ou d'une élision du sujet, par exemple, phénomènes qui interviennent lorsque deux phrases reliées par une conjonction partagent le même verbe, ou le même sujet. Nous proposons un traitement de ces phénomènes dans le formalisme des grammaires catégorielles abstraites selon un patron que nous intitulons extraction/instanciation et que nous implémentons de deux manières différentes dans les ACGs. BSTRACT Treating ellipsis : two abstract categorial grammar perspectives  The treatment of ellipsis in models of the syntax-semantics interface is troublesome as  the linguistic material removed in the phonologic interpretation is still necessary in the semantics. Examples are particular cases of coordination, especially the ones involving verbal phrase ellipsis or subject elision. We show a way to use abstract categorial grammars so as to implement a pattern we call extraction/instantiation in order to deal with some of these phenomena ; we exhibit two different constructions of this principle into ACGs. OTS CLÉS ellipse, coordination, interface syntaxe-sémantique, grammaires catégorielles abstraites, grammaires d'arbres adjoints, grammaires IO d'arbres. EYWORDS ellipsis, coordination, syntax-semantics interface, abstract categorial grammars, tree-adjoining grammars, IO tree-grammars.  La description de la syntaxe du langage naturel par le biais de formalismes symboliques a  donné lieu à la création de nombreux modèles tels que les grammaires non-contextuelles, comme première approximation, et plus récemment les grammaires catégorielles combinatoires (CCGs pour combinatory categorial grammars) (Steedman, 1987) ou les grammaires d'arbres adjoints (Joshi et al., 1975; Joshi, 1985) (TAGs pour tree-adjoining grammars). Tous ces formalismes partagent la propriété de ne pas effacer, et de ne pas copier de matériel syntaxique ou phonologique : nous parlerons de propriété de linéarité. Cependant, certains phénomènes syntaxiques usuels semblent nécessiter des mécanismes de copie et/ou d'effacement :  (1) Marie mange une pizza, et Pierre  des pâtes.  (2) Jean fait un footing et  rattrape Marie. (3) Jean prépare  et Marie vend des crêpes. Sur les exemples ci-dessus, des éléments phonologiques sont absents par économie de langage : le verbe "mange" en (1), et les syntagmes "Jean" en (2) et "des crêpes" en (3). Tous ces éléments sont néanmoins présents au niveau de l'arbre syntaxique (pour la correction grammaticale) ou de la sémantique. Par ailleurs, ces trois exemples partagent la présence de la conjonction de coordination "et" reliant deux phrases. Nous nous intéressons au traitement de ces phénomènes d'ellipse sous la présence de marqueurs de coordination. Plusieurs solutions à ce problème ont été proposées afin d'étendre les formalismes grammaticaux cités ci-dessus. Ainsi, (Steedman, 1990) montre comment traiter de telles coordinations dans les CCGs ; ces idées ont ensuite été implémentées par (Sarkar et Joshi, 1996) dans les TAGs, en étendant le formalisme initial afin d'enrichir les arbres de dérivation par une notion de partage de noeuds, idée ensuite reprise dans (Seddah, 2008; Seddah et al., 2010). Enfin, (Kobele, 2007) propose l'utilisation de grammaires non-contextuelles d'arbres avec copie IO (notées IO-CFTGs pour IO context-free tree grammars).  Nous proposons d'utiliser un formalisme plus expressif que les précédents, à savoir les  grammaires catégorielles abstraites (ACGs pour abstract categorial grammars) (de Groote, 2001; Muskens, 2001). Il est en effet possible d'encoder des grammaires de chaînes ou des grammaires d'arbres dans les ACGs. Qui plus est, la notion de dérivation y est également relativement flexible puisqu'il est possible de considérer non seulement des arbres mais aussi des -termes comme structures de dérivation. En utilisant ces avantages, nous implémentons le principe suivant : une phrase où une ellipse intervient est d'abord partiellement construite, en omettant le constituant commun, qui est rajouté lors de l'étape suivante. Ce principe peut être naturellement réalisé dans le -calcul par le biais de la substitution de termes. En suivant ce principe, nous présentons deux méthodes, la première faisant intervenir la substitution au niveau des structures de dérivation (ou tectogrammaire), la seconde au niveau de la syntaxe (ou phénogrammaire). Nous discutons des avantages de chacune des deux méthodes, et en particulier de l'existence d'algorithmes d'analyse s'exécutant en temps polynomial pour chacune d'elles.  Le reste de cet article est structuré comme suit : en section 2, nous présentons les ACGs. En  section 3, les deux approches que nous proposons seront détaillées et discutées. Enfin, en section 4, nous comparerons notre solution à celles existantes dans la littérature. Les grammaires catégorielles abstraites peuvent être vues comme des grammaires de termes simplement typés. Étant donné un ensemble de types atomiques  , nous définissons l'ensemble  ( ) des types simples sur  par   ( ) ::=  |( ( )   ( ))   Nous adopterons la notation usuelle permettant d'omettre certaines parenthèses : un type  (  (   )) sera noté      .  Une signature d'ordre supérieur est un tuple  = ( , C, ) où :  -  est un ensemble fini de types atomiques. - C est un ensemble fini de constantes. -  est une fonction d'assignation de types de C dans  ( ). Afin de construire des termes sur une telle signature, nous nous donnons un ensemble de variables typées : la notation x désignera une variable x de type . Étant donnés une signature  = ( , C, ) et un type    ( ), l'ensemble  () des -termes de type  dans  se définit par induction :  1. une variable x  appartient à  (). 2. une constante c de C appartient à  () si (c) = . 3. si M est un terme de  () et si  =    , alors x .M est un terme de  (). 4. si M appartient à  () et M à  (), alors (M M ) appartient à  (). L'ensemble des termes simplement typés de  est donné par () = ( ()) . Nous adopterons la convention usuelle suivante : un terme (. . . ((M M )M ) . . . M ) sera écrit M M M . . . M . De plus, nous omettrons d'écrire les types des variables lorsqu'ils ne sont pas indispensables à la compréhension. Nous supposerons que les notions de variables libres et de -réduction sont connues ; nous noterons F V (M) l'ensemble des variables libres d'un terme M ; M  M la -réduction d'un terme M en M en un nombre arbitraire de -contractions, et |M| la forme -normale d'un terme simplement typé. Pour plus de détails sur le -calcul simplement typé, le lecteur peut se référer à (Hindley, 1997).  L'ensemble Lin  () des termes linéaires de type  dans  est défini par induction sur les règles 1. et 2. ci-dessus (en remplaçant  () par Lin ()) et : 3'. si M est un terme de Lin (), si  =    et si x  FV (M), alors x .M est un terme de Lin (). 4'. si M appartient à Lin (), M à Lin () et que F V (M ) F V (M ) = , alors (M M ) appartient à Lin (). L'ensemble QAff () des termes quasi-affines de type  dans  est construit par induction sur les règles 1., 2., 3. et la règle suivante : 4". si M appartient à QAff (), M à QAff () et que pour toute variable x  FV (M ) F V (M ),    , alors (M M ) appartient à QAff (). L'ordre () d'un type  se définit par induction sur  : si    alors () = 1 ; sinon,  =    et () = max( ( ) + 1, ( )). Par extension, l'ordre d'une signature  = ( , C, ) se définit comme : () = max ( ((c))). Remarquons qu'il est possible de voir une signature d'arbre comme une signature d'ordre 2 : dans une telle signature, tout terme M de type atomique et tel que F V (M) =  peut effectivement être interprété comme un arbre. Par exemple, l'arbre f (a, b, g(c)) peut être représenté par le terme f a b (g c ), où o est un type atomique. De plus, si toutes les constantes d'une signature d'ordre 2 sont de type o  o (où o est un type atomique), les termes de la signature peuvent être interprétés comme des chaînes : la chaîne "Jean mange une pomme" est ainsi représentée par le terme x .Jean(mange(une(pomme x))).  Étant données deux signatures   = ( , C ,  ) et  = ( , C ,  ), un morphisme  de  vers  est défini à partir d'un couple de fonctions [ ;  ] vérifiant : - étant donné un type    ( ) : -  () =  ()   ( ) si  appartient à  . -  () =  ( )   ( ) si  =    . - étant donné un terme M de ( ) : - si M = x ,  (M) = x ; - si M = c  C et  (c) = ,  (M)   ( ) ; - si M = x .N,  (M) =  (x ). (N). - si M = M M , alors  (M) =  (M ) (M ). Finalement, une ACG G est définie comme un tuple ( ,  ,  , s) où  et  sont deux signatures d'ordre supérieur (appelées respectivement signature abstraite et objet de G),  est un morphisme de  vers  , et s est un type atomique de  . Une telle grammaire définit deux langages : un langage abstrait A(G) = {M  Lin ( ) | F V (M) = } ; un langage objet O(G) = {M  ( ) | N  A(G), | (N)| = M}. De manière informelle, le langage abstrait correspond à l'ensemble des dérivations du langage O(G) généré par la grammaire.  Une ACG G est d'ordre n   si la signature abstraite de G est d'ordre n (nous écrirons que  G est une n-ACG) ; de plus, une n-ACG est dite linéaire (resp. quasi-affine) si pour toute constante c de la signature abstraite de G,  (c) est un terme linéaire (resp. quasi-affine).            F  1 - Exemple de modélisation de l'interface syntaxe-sémantique par des ACGs  Grâce au pouvoir expressif du -calcul, (de Groote, 2002) et (de Groote et Pogodalla, 2004)  ont montré qu'il est possible d'encoder de nombreux formalismes grammaticaux, dont les TAGs, comme des 2-ACG linéaires. Par ailleurs, lorsqu'on adopte l'hypothèse de compositionnalité, il est possible de représenter l'interface syntaxe-sémantique par l'intermédiaire de deux ACGs G = ( ,  ,  , s) et G = ( ,  ,  , s) (voire (de Groote, 2001; Pogodalla, 2004, 2007) pour plus de détails). Un des avantages de ce modèle est donc de représenter syntaxique et sémantique en parallèle, tout en traitant certains problèmes à des niveaux différents (par exemple, l'ordonnancement des mots peut être traité au niveau de la syntaxe, voire de la réalisation de surface, et non pas au niveau des dérivations). De plus, il est facile d'isoler les différentes représentations d'une phrase, tel que montré sur la figure 1.  Comme énoncé en introduction, nous souhaitons séparer la construction de phrases avec  ellipses en deux étapes : la première consiste à construire une représentation incomplète ; la seconde à instancier cette représentation à l'aide de l'élément partagé. Au niveau de la représentation de surface seule une de ces occurrences sera réalisée. Ainsi, pour la phrase "Jean mange une pizza et Pierre, des pâtes", nous pouvons considérer que nous avons deux constituants incomplets, "Jean  une pizza" et "Pierre  des pâtes" qui sont reliés par la conjonction "et". Le verbe "mange" est ensuite rajouté à chacun de ces deux constituants, bien que non-réalisé phonétiquement pour le second. Le fait de garder une copie du constituant commun est nécessaire dans les ACGs puisque les dérivations des représentations syntaxiques et sémantiques sont symétriques, et qu'une copie de la forme sémantique du constituant commun est nécessaire, comme illustré dans la formule logique (x.Pizza(x)  Mange(x, Jean)  ( y.PlatPates( y)  Mange( y, Pierre)) représentant la sémantique de la phrase ci-dessus. La modélisation du principe extraction/instanciation est réalisée de manière relativement naturel dans le -calcul simplement typé. En effet, un objet incomplet peut être représenté par un terme de la forme x.M, où x est une variable dont les occurrences libres dans M représentent des emplacements vides de l'objet M. L'instanciation de ces emplacements par un objet N est ensuite simplement réalisée par application dans le -calcul et le terme (x.M)N est donc l'objet M où les occurrences (libres) de x (dans M) sont substitués par N.  Dans ce premier modèle, nous montrons comment la construction de constituants incomplets  peut se réaliser au niveau de la signature des dérivations. Cette approche nous amène à écrire des ACGs dont l'ordre est supérieur à 2 ; en effet, à une phrase à laquelle il manque un verbe transitif sera associée une dérivation de la forme x.M, de type (np  np  s)  s ; la conjonction de deux phrases incomplètes implique de prendre deux termes de ce type en argument, et donc de manipuler des constantes d'ordre 4.  En guise d'exemple, nous considérons la grammaire suivante G  = ( ,  ,  , s), afin d'illustrer la modélisation d'ellipses verbales :  -   =       = {np, s} c , c , c , c : np c : np  np  s c :      (où  = (np  np  s)  s)  -   =   = {} Jean, Luc, Pierre, Mohamed, aime, et :     -   =                np, s :=    (noté  ) c := x .Jeanx c := x .Lucx c := x .Mohamedx c := x .Pierrex c := P Q x .Q(aime(P x)) c := P Q R x .PR(et(Q(S S y .S (S y))x))  (où  désigne le type       ) Le terme M = c (P .Pc c )(P .Pc c )c appartient à  ( ). De plus, il est possible de vérifier que  (M ) se -réduit en x.Jean(aime(Luc(et(Pierre(Mohamedx))))). L'ACG ainsi obtenue est une 4-ACG linéaire.  Cette construction peut s'étendre à d'autres types d'ellipses, tels que les ellipses du sujet ou  de l'objet : il suffit alors de rajouter des constantes c et c de type (np  s)  (np  s)  np  s dans  . Comme alternative, nous pouvons envisager la généralisation de cette constante à un type X  X  X tel que proposer dans (Steedman, 1990).  Afin de construire la représentation sémantique de cet exemple, il nous suffit de créer une  seconde ACG G = ( ,  ,  , s) comme suit :  -   =       = {e, t} J, L, P, M : e A : e  e  t  : t  t  t  -   =                np := (e  t)  t (noté ) s := t c := P .PJ c := P .PL c := P .PM c := P .PP c := P Q .P(x .Q(y .Ax y) c := P P R .  (P R)(P R) Cette construction nous permet d'obtenir une 4-ACG ( ,  ,  , s). Nous remarquerons, néanmoins, que cette dernière n'est ni linéaire, ni quasi-affine : en effet, la variable R a deux occurrences libres dans un sous-terme de  (c ).  Commentaires :  Les deux ACGs ainsi construites sont donc des n-ACGs où n > 2 ; ceci soulève un des inconvénients de cette méthode, puisque nous savons que, dans ce cas, le problème de l'appartenance est un problème NP-complet (Kanazawa et Yoshinaka, 2005a), lorsque l'ACG est linéaire.  Du point de vue de la modélisation linguistique, notons qu'il est possible de traiter des  cas d'ellipses multiples d'un même constituant sans modifier notre modèle. Ainsi, afin de pouvoir dériver la phrase : "Jean aime Luc, Pierre, Mohamed et Paul, Valérie.", nous rajoutons la constante c de type      (où  = (np  np  s)  s) à  et telle que  (c ) = P Q R x .PR(,(Q(S S y .S (S y))x)) (en considérant les notations de types ci-dessus). Il est intéressant de remarquer que nous obtenons alors deux termes M et M dans  ( ) tels que | (M )| et | (M )| sont égaux à x.Jean(aime(Luc(,(Pierre(Mohamed(et(Paul(Valériex)))))))). Ces deux termes sont :  1. M  = c (P.Pc c )(Q.c (R.Rc c )(R.Rc c )Q)c correspondant à la dérivation de la phrase pour le parenthésage "[Jean aime Luc, [Pierre, Mohamed et Paul, Valérie]]" ;  2. M  = c (Q.c (P.Pc c )(P.Pc c )Q)(R.Rc c )c correspondant à la dérivation de notre exemple pour le parenthésage "[[Jean aime Luc, Pierre, Mohamed] et Paul, Valérie]" ;  Par ailleurs, remarquons que le verbe n'est réalisé au niveau de la surface que dans le premier  constituant gauche dominé par la coordination ; dans le second cas, il est remonté jusqu'au constituant correct de manière transitive. La grammaire reste alors une 4-ACG linéaire. Cette construction peut s'étendre à l'analyse de phénomènes d'ellipses enchâssées comme dans la phrase suivante en Anglais : (4) After seeing John running a marathon, Paul planned to  , but Mary didn't  . Après avoir vu John courir un marathon, Paul a prévu de le faire, mais pas Marie. En simplifiant quelque peu la dérivation syntaxique, cette phrase est traitée dans notre modèle par l'intermédiaire d'un terme c M (P.c M M (c P))c ; le morphisme est ensuite construit en suivant l'exemple précédent.  Il est important de remarquer la similitude entre cette construction et certains travaux  antérieurs sur les ACGs. En effet, cette méthode repose sur le fait de retarder la concaténation de chaînes, de la même manière que (Pogodalla, 2007) utilise des ACGs d'ordre supérieur au niveau des dérivations afin de retarder l'ajout de matériel linguistique, permettant ainsi de modéliser les différentes portées des quantificateurs dans la représentation sémantique.  Remarquons enfin, que nous avons modélisé la réalisation de surface sans décrire la réalisation  de l'arbre syntaxique ; cette construction ne nous apporte effectivement aucune information supplémentaire sur l'analyse de cette première modélisation.  Par ces divers exemples, nous montrons qu'il est possible de modéliser divers phénomènes  d'ellipses de manière simple et élégante dans les ACGs, sans modifier le formalisme. Notre construction repose uniquement sur le fait de considérer des termes d'ordre supérieur au niveau des dérivations. Néanmoins, l'inconvénient d'une telle construction est que le traitement de ces phénomènes ne peut plus être réalisé en temps polynomial. Nous montrons à présent qu'une solution possible à ce problème consiste à considérer des ACGs d'ordre 2, et à enrichir le typage de la signature des dérivations, plutôt que la structure des termes.  Dans cette seconde approche, nous construisons des modèles de représentation de la structure  de surface à partir des structures de dérivation de manière indirecte, par l'intermédiaire des structures syntaxiques arborescentes. Ceci nous permettra, en particulier, de mettre en avant la complexité des morphismes utilisés, cette propriété ayant un impact sur la complexité de l'analyse dans les ACGs . Pour ce faire, nous introduisons un opérateur DEL d'effacement au niveau des arbres syntaxiques, à la manière de (Kobele, 2007) ou de l'opérateur de "deanchoring" sur les structures de dérivation dans (Lichte et Kallmeyer, 2010). Dans notre cas, un sous-arbre dominé par cet opérateur sera interprété comme la chaîne vide  au niveau de la représentation de surface. Cet opérateur n'est donc pas indispensable à notre modèle, mais nous permet néanmoins de faire apparaître l'élément effacé dans l'arbre syntaxique.  Nous donnons un exemple d'un tel arbre en Figure 2, dérivé par la grammaire G  = ( ,  ,  , o) définie par : S  S   NP   J  VP  TV  NP  Det  N Coord S  NP   P  VP  DEL   TV  NP  Det  N  F  2 - Arbre dérivé pour la phrase "Jean mange une pizza et Pierre, des pâtes."  -   =       = {o} S : o  o  o  o NP , N, Det, Coord, TV, DEL : o  o S, N P , V P : o  o  o J , , P , , , , , : o  -   =   = {} Jean, mange, une, des, pizza, pâtes, et :     -   =                      o :=    S := P P P x .P (P (P x)) S, NP , VP := P P x .P (P x) N, NP , Det, Coord, TV := P x .P x DEL : P x .x J := x .Jeanx, P := x .Pierrex := x .mangex := x .unex, := x .desx := x .pizzax := x .pâtesx := x .etx Nous remarquerons que l'opérateur DEL réalise l'effacement au niveau de la chaîne de caractères ; en effet, l'image de ce terme par le morphisme  est un terme quasi-affine, effaçant sur son premier argument. Ainsi, pour tout terme M, nous avons  (DELM) x.x. Nous pouvons alors vérifier que le terme M correspondant à l'arbre de la figure 2 vérifie  (M ) x.Jean(mange(une(pizza(et(Pierre(des(pâtesx))))))) . Par ailleurs, l'ACG ainsi présentée n'est pas lexicalisée : l'image de certaines constantes de  par  ne contient pas de constantes. Néanmoins, nous savons qu'il est possible de construire une 2-ACG lexicalisée générant le même langage (Kanazawa et Yoshinaka, 2005b).  Nous décrivons à présent, une seconde implémentation du principe d'extraction/instanciation,  en créant de nouveaux types dans la signature des dérivations : le fait qu'un constituant d'une certaine catégorie syntaxique soit incomplet pour une autre catégorie syntaxique sera effectivement dénoté par un type distinct.  En reprenant l'exemple de la figure 2, nous souhaitons donc pouvoir dériver un terme de  la forme x .M et un terme x .M représentant chacun les contextes d'arbre pour "Jean x une pizza" et pour "Pierre x des pâtes", sachant que pour ce dernier, l'occurrence de x est dominée par une occurrence de l'opérateur DEL. Nous créons donc un type (noté s ) pour désigner les contextes d'arbre sur un verbe transitif, au niveau des dérivations. De plus,  (s ) = o  o, afin de rendre compte du fait que la dérivation d'un terme de type s est un contexte d'arbre, tel que nous le codons dans le -calcul.  Une constante c  est ensuite nécessaire à  afin de réaliser l'étape d'instanciation, mais cette fois au niveau des termes des arbres syntaxiques ; il suffit donc de typer cette constante par s  s  tv  s, un type d'ordre 2. On notera que pour ce faire, nous modifions le type associé aux verbes transitifs de np  np  s en tv. Intuitivement, ceci revient à associer à un verbe le plus grand sous-arbre dont l'unique racine est la réalisation phonologique associée au verbe.  Afin d'illustrer notre proposition, nous donnons la grammaire G  = ( ,  ,  , s) définie ci-dessous. Afin de mieux dissocier les deux étapes de notre méthode, nous isolons l'étape d'instanciation par l'intermédiaire d'une constante distincte, c , le type de la variable c s'en trouvant alors modifié :  -   =                   = {s, s , vp , n, np, v} c : s  s  s c : s  tv  s c : np  vp  s c : np  vp c : n  det  np c , c : np c : t v c , c : det c , c : n  -   =                            s, t v, n, np, det := o s , vp := o  o c := P x .P x c := P P x .S(P x)(Coord )(P (DELx)) c := t P x .St(P x) c := t x .VPx t c := t t .NP t t c := NP J , c := NP P c : V c := Det , c := Det c : N , c : N  En considérant la signature abstraite   , nous obtenons un terme M appartenant au langage abstrait et tel que M = c M M où  1. M  = c (c c (c (c c c )))(c c (c (c c c ))) et  2. M  = c .  Nous remarquerons que   (M ) s'interprète alors comme un contexte d'arbre, de la forme x .T , T étant l'arbre de la figure 2 où les occurrences du sous-arbre V sont remplacées par x.  Commentaires   Tout d'abord, remarquons que l'ACG G = (  ,  ,  , s) est une 2-ACG quasi-affine. D'après (Bourreau et Salvati, 2011; Bourreau, 2011) ou (Kanazawa, 2007; Yoshinaka, 2006), nous savons que le problème de l'analyse, dans ce cas, peut être résolu en temps polynomial. Ce point différencie donc les deux approches présentées. Ensuite, nous remarquerons qu'il est à nouveau possible de généraliser le type associé à la conjonction c au niveau des dérivations en     , avec,    . Néanmoins, comme nous l'avons remarqué, l'ACG ( ,  ,  , o) n'est pas lexicalisée. Le fait de considérer l'ACG lexicalisée équivalente ( ,  ,  , o) de (Kanazawa et Yoshinaka, 2005b) peut a priori avoir un certain impact sur la construction de l'ACG ( ,  ,  , s), cette question demandant à être étudiée plus en détails. Par ailleurs, le choix d'introduire l'opérateur DEL n'est destiné qu'à faire apparaître l'occurrence de constituant effacée dans l'arbre syntaxique. En effet, il est possible de modifier notre modèle de sorte que  (c ) = P P x .S(P x)(Conj )(P ), où  est alors une constante de  , de type o et telle que  () = x .x . Dans cette proposition alternative, l'ACG obtenue reste une 2-ACG linéaire.  La gestion de l'effacement par enrichissement des types peut également s'étendre à l'analyse  de phénomènes d'ellipses enchâssées comme dans la phrase (4) de la section précédente. Un tel cas peut-être traité dans notre proposition en rajoutant une étape supplémentaire d'extraction/instanciation, par l'intermédiaire d'une constante c de type s  vp  s , et telle que  (c ) = P P t .P (P t). L'utilisation d'une telle constante réalise alors l'instanciation d'emplacements vides dans un arbre de type s par un contexte d'arbre de type vp . La dérivation de cet exemple est donc réalisée en construisant d'abord deux contextes d'arbre : Le terme  (c ) permet alors de substituer les occurrences de x dans  S   S   NP   Paul  x :VP Coord  but  S  NP   Mary  VP  Neg   V   does  not DEL  x :VP  VP  V   planned to  y :VPinf  F  3 - Représentation de la dérivation pour "John planned to but Mary does not"  le premier arbre par le second ; il suffit ensuite de suivre la procédure sur notre exemple  initiale pour obtenir l'arbre souhaité. Nous pouvons alors voir que l'inconvénient principal de cette méthode est de devoir créer de nombreux types afin de prendre en compte les différents cas d'ellipses possibles, selon le constituant effacé. Notons également qu'il est possible de construire la sémantique associée à une phrase où une ellipse a été réalisée, de manière similaire à la construction précédente. Finalement, il apparaît que les deux constructions présentées sont liées : notre deuxième proposition repose sur le fait de décomposer les arbres syntaxiques en unité plus petite, ce qui aboutit à considérer une ACG non-lexicalisée, et à considérer un nombre de types plus grand. Cependant, il nous faudra étudier ce lien, et la possibilité d'abaisser l'ordre d'une ACG tout en préservant le langage généré.  Une première possibilité de traitement de certains phénomènes d'ellipse consiste à reprendre  les idées de (Steedman, 1990) pour les grammaires catégorielles combinatoires, et à implémenter ces idées dans les ACGs. Steedman suggère, en particulier, l'utilisation d'un combinateur T de "type raising" afin de traiter des phénomènes d'élision du sujet ou de l'objet ; de plus, les ellipses verbales nécessitent l'introduction d'un combinateur supplémentaire Bx qui permet de rompre avec la directionnalité du calcul logique sous-jacent, et un opérateur de décomposition de type, permettant d'extraire le verbe d'une phrase.  Dans le cadre des ACGs, l'opérateur Bx n'est pas nécessaires, puisque les types ne sont pas  dirigés. l'utilisation du combinateur T revient à modifier les types assignés aux constantes de la signature des structures de dérivation. Sur un exemple, nous pouvons décrire une signature des dérivations faite des constantes c , c : (np  s)  s, c : np  s, c : np  np  s et c : (np  s)  (np  s)  (np  s). Cette signature permet de dériver un terme c ( y .c (c c (c y))). Grâce au morphisme  cidessous, il est ensuite possible d'associer la forme sémantique souhaitée pour la phrase "Jean court et rattrape Marie" :  -   =          np := e s := t c := P .PJ c := P .PM c := x y .Rx y c := x .Cx c := P P x .  (P x)(P x) Nous remarquerons néanmoins que, la signature des dérivations que nous décrivons ci-dessus est d'ordre supérieur à 2. Par ailleurs, il ne semble pas souhaitable, dans le cas des ACGs, de typer tous les syntagmes nominaux par un type (np  s)  s, ce qui revient à considérer des ACGs d'ordre supérieur à 2 pour des cas très simples, sans phénomènes d'ellipses. Enfin, l'opérateur de décomposition est nécessaire dans le cas d'ellipses verbales pour les langues de type SVO, car il permet d'extraire le verbe de la phrase en partie gauche de la conjonction. Cet opérateur permet en fait d'effectuer le même traitement que nous réalisons, c.a.d. de construire des constituants incomplets puis de les composer avec le constituant commun. Qui plus est, cet opérateur de décomposition semble poser un problème du point de vue calculatoire car il introduit deux nouvelles formules, ce qui va à l'encontre de la propriété de la sous-formule. Enfin, notons que les ACGs permettent l'implémentation du même principe de manière plus élégante puisque, de par l'indépendance entre dérivations et ordre des mots, nous n'avons pas eu besoin d'enrichir le formalisme initial de nouveaux opérateurs.  Des extensions des TAGs ont également été proposées, tout d'abord dans (Sarkar et Joshi,  1996) qui proposent une implémentation des idées de (Steedman, 1990) dans les grammaires d'arbres adjoints, en y rajoutant une opération de conjonction. Par ailleurs, l'objectif des auteurs est de construire des structures dérivées qui sont des arbres avec partage de noeud. Qui plus est, ils rendent compte de ce partage de matériel syntaxique au niveau des dérivations, les structures de dérivation étant également des arbres avec partage de noeuds. Ceci est dû au fait que les structures de dérivation dans les TAGs sont censés être plus proches de la structure prédicat/argument de représentation sémantique d'une phrase. D'autres propositions sont celles de (Seddah, 2008) ou (Seddah et al., 2010), qui considèrent des grammaires de tuples d'arbres et requièrent des opérations plus complexes ; par exemple, le traitement d'ellipses multiples se fait en ajoutant un nombre arbitraire d'arbres non-lexicalisés (appelés "ghost trees" par les auteurs). L'originalité de notre méthode, par rapport à celles-ci, est de pouvoir traiter les phénomènes d'ellipses que nous avons étudiés sans modifier le formalisme des grammaires catégorielles abstraites. Par ailleurs, le modèle de l'interface syntaxe sémantique dans les ACGs permet de séparer explicitement les structures de dérivation, de la représentation sémantique. Le partage d'information nécessaire au niveau des dérivations dans les TAGs, est donné au niveau de la signature  dans notre cas. Enfin, (Kobele, 2007) décrit plusieurs méthodes possibles dont les deux suivantes : la première consiste à construire des contextes d'arbres, car du matériel syntaxique est absent aux emplacements où une ellipse a été réalisée ; l'information manquante doit alors être retrouvée dans l'arbre (dans le cas d'une ellipse verbale, dans le premier constituant dominé par une conjonction de coordination). La deuxième approche de (Kobele, 2007) consiste à utiliser des grammaires non-contextuelles d'arbres avec copie IO.  Les deux approches que nous proposons semblent assez proches des propositions de Kobele,  à la différence que, plutôt que de rechercher le matériel effacé dans l'arbre, nous mettons en place un mécanisme permettant de le copier. Par ailleurs, les ACGs de notre seconde approche peuvent être réduites à des grammaires IO-CFTGs. Bien que le patron de dérivation ne soit pas le même que celui utilisé par Kobele, il semblerait que nous ne puissions pas traiter plus de phénomènes que dans son approche. En particulier, Kobele montre qu'une des limites de l'approche par des IO-CFTGs est de ne pas pouvoir traiter des phénomènes tels que : (5). "John wants to climb Mt. Kilimanjaro and Mary to sail around the world, and while I know that John will  and Mary won't  , Bill doesn't  " John veut grimper le Kilimanjaro et Marie naviguer autour du monde, et alors que je sais que John le fera et pas Marie, Bill ne le sait pas D'après cette construction, il serait nécessaire de garder l'ensemble des verbes utilisés dans le constituant à gauche d'une conjonction afin de pouvoir le réutiliser dans les constituants en partie droite ; qui plus est, ce nombre de verbes est potentiellement infini, ce qui, dans notre première approche nous amène à considérer un nombre de constantes infinies c , n   ; dans notre seconde approche, il nous faudrait considérer un nombre de types infini dans la signature des dérivations. Ces cas d'ellipses mettent en avant la limite des traitements proposées. Par ailleurs, ce type d'ellipses paraît maladroit en Français, où les pronoms sont utilisés afin de se référer à un syntagme précédemment utilisé. Une solution à envisager est donc d'adapter des techniques de résolution d'anaphores, à partir de continuations dans le -calcul, par exemple (de Groote, 2006), afin de résoudre les phénomènes d'ellipse.  Les phénomènes d'ellipses sont fréquents dans le langage naturel et sont des exemples de  phénomènes non-linéaires au niveau de l'interface syntaxe-sémantique. Nous avons proposé deux approches pour le traitement d'ellipses sous coordination dans les ACGs, en utilisant le principe d'extraction pour la construction d'une phrase incomplète, suivi d'un mécanisme d'instanciation, modélisé par la substitution dans le -calcul. Dans la première approche, ce principe est directement codé au niveau des termes des structures de dérivation ; de manière élégante, nous pouvons alors traiter de nombreux cas d'ellipses, mais la signature des dérivations étant d'ordre supérieur à 2, le problème de l'analyse est, au meilleur des cas, NP-complet. Dans la deuxième approche, nous conservons une ACG d'ordre 2, mais les mécanismes d'extraction sont encodés au niveau des types utilisés dans la signature. Ceci nous amène alors à considérer un ensemble de types très grand, mais nous permet de réutiliser des algorithmes d'analyse connus pour s'exécuter en temps polynomial.  Les deux approches ainsi proposées ne nécessitent pas d'étendre le formalisme des ACGs,  contrairement aux solutions proposées dans la littérature, pour les TAGs ou les CCGs. Néanmoins, les modélisations que nous proposons ne prétendent pas résoudre des phénomènes d'ellipses complexes, tels que les ellipses de verbes prenant différentes catégories en argument (dans "Jean est un républicain, et fier de l'être"), ou encore celles faisant intervenir un zeugma (dans "Napoléon a pris du poids et beaucoup de pays", discuté dans (Seddah, 2008)). Dans ce dernier cas, une piste est de tenter de distinguer deux signatures des dérivations  et  contrôlant les dérivations de l'arbre syntaxique, la première s'assurant de la construction d'expressions figées.  Par ailleurs, les modèles que nous proposons reposent essentiellement sur la présence d'une  coordination dominant l'occurrence du syntagme effacé, et ne saurait résoudre des cas d'ellipses ou ce principe n'est pas vérifié. Enfin, et comme discuté dans (Kobele, 2007), les deux approches semblent trop limités afin de résoudre certains cas d'ellipses faisant intervenir de multiples verbes, et des méthodes de résolution d'anaphores pourrait se montrer plus efficaces.  Finalement, cette étude demande à être approfondie afin d'étudier plus en détails le lien entre  les deux propositions présentées. En particulier, il serait intéressant de savoir quand, et à quel coût, il est possible de diminuer l'ordre d'une ACG tout en préservant le langage généré. Remerciements : Je remercie les rapporteurs anonymes qui ont grandement aidé à l'amélioration de ce travail. Je tiens également à remercier Laura Kallmeyer et Timm Lichte pour les discussions qui m'ont amenées à m'intéresser à ce problème.  
